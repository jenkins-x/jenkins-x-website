<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins X - Cloud Native CI/CD Built On Kubernetes – About</title>
    <link>https://jenkins-x.io/docs/v3/about/</link>
    <description>Recent content in About on Jenkins X - Cloud Native CI/CD Built On Kubernetes</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://jenkins-x.io/docs/v3/about/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Benefits</title>
      <link>https://jenkins-x.io/docs/v3/about/benefits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/docs/v3/about/benefits/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;We can use vanilla tools like &lt;a href=&#34;https://helm.sh/&#34;&gt;helm 3&lt;/a&gt;, &lt;a href=&#34;https://github.com/roboll/helmfile&#34;&gt;helmfile&lt;/a&gt;, &lt;a href=&#34;https://kustomize.io/&#34;&gt;kustomize&lt;/a&gt;, &lt;a href=&#34;https://googlecontainertools.github.io/kpt/&#34;&gt;kpt&lt;/a&gt; to install, update or delete charts in any namespace without needing helm 2.x or tiller or custom code to manage &lt;code&gt;helm template&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;We can avoid all the complexities of the &lt;code&gt;jx step helm apply&lt;/code&gt; logic we used in Jenkins X 2.x&lt;/li&gt;
&lt;li&gt;Instead we can replace this with vanilla &lt;a href=&#34;https://github.com/roboll/helmfile&#34;&gt;helmfile&lt;/a&gt; to allow optional templating of &lt;code&gt;values.yaml&lt;/code&gt; files when using helm&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The new &lt;a href=&#34;https://jenkins-x.io/docs/v3/getting-started/&#34;&gt;Getting Started&lt;/a&gt; approach is much simpler, easier to configure and customise and is cleanly integrated with tools like Terraform and works well with diffent cloud infrastructure
&lt;ul&gt;
&lt;li&gt;The default install/upgrade pipelines check in all the generated kubernetes resources and custom resources as YAML so its easy to understand&lt;/li&gt;
&lt;li&gt;You can read more about the &lt;a href=&#34;https://github.com/jenkins-x/jx-gitops/blob/master/docs/git_layout.md&#34;&gt;git layout here&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;config-root/cluster&lt;/code&gt; folder contains all the global cluster level resources like &lt;code&gt;ClusterRole&lt;/code&gt;, &lt;code&gt;Namespace&lt;/code&gt; or Custom Resources&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;config-root/namespaces/jx&lt;/code&gt; folder contains all the namespaced resources in the &lt;code&gt;jx&lt;/code&gt; namespace&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;This makes it easy to use flexible apply logic in different boot &lt;code&gt;Jobs&lt;/code&gt; with different RBAC (or a system admin could apply the cluster level resources for you by hand) - to make it easier to install Jenkins X on more locked down and restricted clusters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We use &lt;a href=&#34;https://github.com/godaddy/kubernetes-external-secrets&#34;&gt;Kubernetes External Secrets&lt;/a&gt; to provide a single way to manage secrets which supports the following back end systems:
&lt;ul&gt;
&lt;li&gt;Alibaba Cloud KMS Secret Manager&lt;/li&gt;
&lt;li&gt;AWS Secrets Manager&lt;/li&gt;
&lt;li&gt;Azure Key Vault&lt;/li&gt;
&lt;li&gt;GCP Secret Manager&lt;/li&gt;
&lt;li&gt;Hashicorp Vault&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It opens the door to a flexible &lt;a href=&#34;https://jenkins-x.io/docs/v3/guides/multi-cluster/&#34;&gt;multi-cluster support&lt;/a&gt; so that every cluster can be managed in the same canonical GitOps approach from a single git repository&lt;/li&gt;
&lt;li&gt;The new &lt;a href=&#34;https://jenkins-x.io/docs/v3/getting-started/&#34;&gt;getting started approach&lt;/a&gt; runs the boot pipeline as a &lt;code&gt;Job&lt;/code&gt; inside the Kubernetes cluster. This ensures consistency in tooling used and also improves security by avoiding having the secrets on a developers laptop.
&lt;ul&gt;
&lt;li&gt;The only thing you run on your local machine when installing Jenkins X is &lt;a href=&#34;https://jenkins-x.io/docs/v3/guides/operator/&#34;&gt;installing the git operator&lt;/a&gt; which is a simple helm chart.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Everything is now an app. So if you want to remove our &lt;code&gt;nginx-ingress&lt;/code&gt; chart and replace it with another ingress solution (knative / istio / gloo / ambassador / linkerd or whatever) just go ahead and use the &lt;a href=&#34;https://jenkins-x.io/docs/v3/guides/apps/&#34;&gt;apps commands&lt;/a&gt; to add/remove apps and have boot manage everything in a consistent way
&lt;ul&gt;
&lt;li&gt;e.g. here&amp;rsquo;s &lt;a href=&#34;https://github.com/jx3-gitops-repositories/jx3-kind-vault/blob/master/helmfile.yaml#L17&#34;&gt;an example&lt;/a&gt; of removing &lt;code&gt;chartmusem&lt;/code&gt; and &lt;code&gt;nexus&lt;/code&gt; and replacing it with &lt;code&gt;bucketrepo&lt;/code&gt; via a single simple yaml change.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;You can install an app in a specific namespace if you wish
&lt;ul&gt;
&lt;li&gt;This also opens the door to using boot to setup multi-team installations where multiple teams use different namespaces but share services in the same cluster&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The cluster GitOps repository is simpler and easier to keep in sync/rebase/merge with the upstream git repositories.
&lt;ul&gt;
&lt;li&gt;We use &lt;a href=&#34;https://googlecontainertools.github.io/kpt/&#34;&gt;kpt&lt;/a&gt; to do that for us&lt;/li&gt;
&lt;li&gt;We now include the &lt;a href=&#34;https://jenkins-x.io/about/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; inside your GitOps repository too inside the &lt;code&gt;versionStream&lt;/code&gt; directory after installation so that all the information about your installation is inside a single git repository so its simpler to test changes &amp;amp; ensure consistency.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We can avoid composite charts to simplfiy configuration and upgrades&lt;/li&gt;
&lt;li&gt;We no longer use &lt;code&gt;exposecontroller&lt;/code&gt; and use regular helm configuration to create &lt;code&gt;Ingress&lt;/code&gt; resources and &lt;a href=&#34;https://jenkins-x.io/docs/v3/guides/faq/#how-do-i-configure-the-ingress-domain-in-dev-staging-or-production&#34;&gt;override domain names&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;secret handling is currently much simpler using Kubernetes External Secrets for any secrets in any namespace or cluster for your own apps or for those used by Jenkins X.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Comparison</title>
      <link>https://jenkins-x.io/docs/v3/about/comparison/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/docs/v3/about/comparison/</guid>
      <description>
        
        
        &lt;p&gt;This document outlines the similarities and differences of the 3.x approach for those who are aware of &lt;code&gt;jx boot&lt;/code&gt; with helm 2 in 2.x of Jenkins X.&lt;/p&gt;
&lt;h2 id=&#34;similarities-between-2x-and-3x&#34;&gt;Similarities between 2.x and 3.x&lt;/h2&gt;
&lt;p&gt;Just like classic boot with the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/&#34;&gt;jenkins-x-boot-config&lt;/a&gt; git repository, this new &lt;a href=&#34;https://github.com/roboll/helmfile&#34;&gt;helmfile&lt;/a&gt; solution supports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;you can install and upgrade Jenkins X via GitOps&lt;/li&gt;
&lt;li&gt;you can reuse helm charts from the internet, local charts or charts built by Jenkins X in any environment&lt;/li&gt;
&lt;li&gt;a YAML file is used to store all the charts that are applied during install/upgrade&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;differences-with-in-3x&#34;&gt;Differences with in 3.x&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;we support any permutation of tools such as: &lt;a href=&#34;https://helm.sh/&#34;&gt;helm 3&lt;/a&gt;, &lt;a href=&#34;https://github.com/roboll/helmfile&#34;&gt;helmfile&lt;/a&gt;, &lt;a href=&#34;https://kustomize.io/&#34;&gt;kustomize&lt;/a&gt; and/or &lt;a href=&#34;https://googlecontainertools.github.io/kpt/&#34;&gt;kpt&lt;/a&gt; to create the kubernetes resources&lt;/li&gt;
&lt;li&gt;in 3.x the installation/upgrade of Jenkins X is run inside the kubernetes cluster via a &lt;code&gt;Job&lt;/code&gt; rather than on a developers laptop which helps with consistency and security.&lt;/li&gt;
&lt;li&gt;in 3.x we use a single git repository for each cluster; which can manage as many teams/namespaces as you like within the cluster
&lt;ul&gt;
&lt;li&gt;so any local environments like &lt;code&gt;Staging&lt;/code&gt; which reside in the same kubernetes cluster are defined in the same git repository in 3.x - whereas in 2.x we used a separate git repository for &lt;code&gt;Dev&lt;/code&gt;, &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; when sharing the same cluster.&lt;/li&gt;
&lt;li&gt;if &lt;code&gt;Dev&lt;/code&gt;, &lt;code&gt;Preprod&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; environments are in separate kubernetes clusters then those will have a git repository each.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;any helm chart can be deployed in any namespace (previously we used 1 namespace for all charts in the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/requirements.yaml&#34;&gt;env/requirements.yaml&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;instead of using &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/requirements.yaml&#34;&gt;env/requirements.yaml&lt;/a&gt; we now use a simple and more powerful &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/helmfile.yaml&#34;&gt;helmfile.yaml&lt;/a&gt; file which is similar but supports:
&lt;ul&gt;
&lt;li&gt;we can specify a &lt;code&gt;namespace&lt;/code&gt; on any chart&lt;/li&gt;
&lt;li&gt;we can add extra &lt;code&gt;values&lt;/code&gt; files to use with the chart to override the helm &lt;code&gt;values.yaml&lt;/code&gt; files&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;instead of copying lots of &lt;code&gt;env/$appName/values*.yaml&lt;/code&gt; files into the boot config like we do in &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/&#34;&gt;these folders&lt;/a&gt; such as &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/lighthouse/values.tmpl.yaml&#34;&gt;the lighthouse/values.tmpl.yaml&lt;/a&gt; we can instead default all of these from the version stream at &lt;a href=&#34;https://github.com/jenkins-x/jxr-versions/tree/master/apps/jenkins-x/lighthouse&#34;&gt;apps/jenkins-x/lighthouse&lt;/a&gt; - which means the boot config git repository is much simpler, we can share more configuration with the version stream and it avoids lots of git merge/rebase issues.&lt;/li&gt;
&lt;li&gt;adding and removing apps in your GitOps repository causes those resources to be properly installed or uninstalled
&lt;ul&gt;
&lt;li&gt;you can also review exactly what kubernetes resources will change on the Pull Request&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;we no longer use a composite chart for &lt;code&gt;env/Chart.yaml&lt;/code&gt; and instead deploy each chart independently
&lt;ul&gt;
&lt;li&gt;this means that each chart has its own unique version number you can see in the &lt;code&gt;helmfile.yaml&lt;/code&gt; file&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;we have done away with the complexity of &lt;code&gt;jenkins-x-platform&lt;/code&gt; (a composite chart containing logs of &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform/blob/master/jenkins-x-platform/requirements.yaml&#34;&gt;dependencies&lt;/a&gt; like &lt;code&gt;jenkins&lt;/code&gt; + &lt;code&gt;chartmuseum&lt;/code&gt; + &lt;code&gt;nexus&lt;/code&gt; etc) so that each chart can be added/removed independently or swapped out with a different version/distribution&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Background</title>
      <link>https://jenkins-x.io/docs/v3/about/background/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/docs/v3/about/background/</guid>
      <description>
        
        
        &lt;p&gt;see the &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/6442&#34;&gt;issue&lt;/a&gt; and &lt;a href=&#34;https://github.com/jenkins-x/enhancements/tree/master/proposals/2&#34;&gt;enhancement proopsal&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;
&lt;p&gt;We want a simple canonical way to install any helm chart in any namespace without having to manually hack the &lt;code&gt;jx boot&lt;/code&gt; pipeline file: &lt;code&gt;jenkins-x.yml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This will make it easy for people or software to easily add/remove apps to any git repository for any Environment (dev / staging / production).&lt;/p&gt;
&lt;p&gt;The boot config repo has become quite complex and hard to manage upgrades to and share common config between different flavours of base boot config repos.  It’s also hard to experiment by adding new helm charts / features / applications that require changes to the boot install pipeline.&lt;/p&gt;
&lt;p&gt;We want a simpler more modular system that lets us, say, swap out nginx-controller and use gloo/knative/istio for ingress without a deep knowledge of the jenkins-x.yml pipeline for boot.&lt;/p&gt;
&lt;p&gt;What we’d really like is for folks to type commands like…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx delete app nginx-controller
jx add app istio
jx delete app knative
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And for it to just work and generically add those to the right namespace.&lt;/p&gt;
&lt;h2 id=&#34;current-limitations&#34;&gt;Current Limitations&lt;/h2&gt;
&lt;p&gt;The current apps model lets you add/remove charts fine - but there are a number of limitations:&lt;/p&gt;
&lt;h3 id=&#34;only-works-in-1-namespace&#34;&gt;Only works in 1 namespace&lt;/h3&gt;
&lt;p&gt;Currently apps can only work inside the dev namespace - we can’t support things like knative, gloo, cert-manager, nginx, velero which tend to be installed in separate namespaces.&lt;/p&gt;
&lt;p&gt;### Does not handle boot phases&lt;/p&gt;
&lt;p&gt;This is not surprising as we created the App extension model before boot. But right now boot has a number of distinct phases with pipeline steps between them where we may want to add apps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pre/post ingress setup (in the case of nip.io / nginx-controller)&lt;/li&gt;
&lt;li&gt;pre/post vault setup&lt;/li&gt;
&lt;li&gt;pre/post vault population of parameters&lt;/li&gt;
&lt;li&gt;pre/post setup of certmanager/external dns&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is currently no way for an apps to specify a namespace + specify which phase its to be installed in &amp;amp; have (say) the domain / certs / secrets injected easily.&lt;/p&gt;
&lt;p&gt;So rather than adding steps at the right point in a list of steps in the jenkins-x.yml it would be nice to have a more declarative YAML file to describe which apps are to be enabled.&lt;/p&gt;
&lt;p&gt;E.g. we need a new YAML file with list of charts to be installed along with metadata for which phase to install them. We also want to invoke a selection of those appss to be installed at the different phases of the boot pipeline.&lt;/p&gt;
&lt;h3 id=&#34;limitations-of-the-current-deploy-model&#34;&gt;Limitations of the current deploy model&lt;/h3&gt;
&lt;p&gt;We have some issues with the current way we deploy apps in Staging / Production:&lt;/p&gt;
&lt;h4 id=&#34;composite-charts-hide-the-individual-versions&#34;&gt;Composite charts hide the individual versions&lt;/h4&gt;
&lt;p&gt;Right now we deploy all charts in Staging/Production as a single chart. That means if you use &lt;code&gt;helm list&lt;/code&gt; we don&amp;rsquo;t show any actual versions of the dependent charts - its just 1 chart (with no version).&lt;/p&gt;
&lt;h4 id=&#34;removing-apps-on-dev-doesnt-work&#34;&gt;Removing Apps on Dev doesn&amp;rsquo;t work&lt;/h4&gt;
&lt;p&gt;If you remove a chart from &lt;code&gt;env/requirements.yaml&lt;/code&gt;  in the Dev repository the pipeline does not remove the chart. e.g. if you add &lt;code&gt;lighthouse&lt;/code&gt; and remove &lt;code&gt;prow&lt;/code&gt; you need to manually delete the prow resources yourself.&lt;/p&gt;
&lt;h3 id=&#34;limitation-of-boot&#34;&gt;Limitation of boot&lt;/h3&gt;
&lt;p&gt;We currently manually configure in the boot pipeline the install of multiple systems usually in separate namespaces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;velero (if enabled)&lt;/li&gt;
&lt;li&gt;nginx&lt;/li&gt;
&lt;li&gt;externaldns&lt;/li&gt;
&lt;li&gt;cert-manager&lt;/li&gt;
&lt;li&gt;acme certs chart&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ideally those should be modular and optional. e.g it should be really trivial to disable nginx if folks are using, say, istio - without having to hack a pipeline yaml.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;d also like to make it easy to add a number of other systems in order in separate namespaces independently of the &lt;code&gt;Staging / Production&lt;/code&gt; environment namespaces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;knative &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/6331&#34;&gt;https://github.com/jenkins-x/jx/issues/6331&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gloo&lt;/li&gt;
&lt;li&gt;istio&lt;/li&gt;
&lt;li&gt;linkerd &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/6330&#34;&gt;https://github.com/jenkins-x/jx/issues/6330&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;flagger&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so it&amp;rsquo;d be nice to have a simple app model where anyone can add any systems/charts to any namespace at any point in the flow before we setup the dev/staging/production environment in the traditional way.&lt;/p&gt;
&lt;h2 id=&#34;proposal&#34;&gt;Proposal&lt;/h2&gt;
&lt;p&gt;We propose we combine the extensibility of Jenkins X using Apps with &lt;code&gt;jx boot&lt;/code&gt; via a simple declarative YAML file declaring the charts to be installed.&lt;/p&gt;
&lt;p&gt;e.g. a file &lt;code&gt;apps.yaml&lt;/code&gt;  something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;defaultNamespace&lt;/span&gt;: jx

&lt;span style=&#34;color:#66d9ef&#34;&gt;releases&lt;/span&gt;: 
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: velero
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: velero
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://kubernetes-charts.storage.googleapis.com
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: system  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: velero   
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: nginx-ingress
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: nginx-ingress
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://kubernetes-charts.storage.googleapis.com
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: system  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: kube-system   
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: external-dns
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://charts.bitnami.com/bitnami
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: post-ingress  
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: cert-manager
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: cert-manager
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://charts.jetstack.io
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: cert-manager  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: post-ingress  
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: jxboot-resources
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: tekton
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: tekton
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: prow
  &lt;span style=&#34;color:#66d9ef&#34;&gt;condition&lt;/span&gt;: prow.enabled
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: prow
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: lighthouse
  &lt;span style=&#34;color:#66d9ef&#34;&gt;condition&lt;/span&gt;: lighthouse.enabled
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: lighthouse
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: bucketrepo
  &lt;span style=&#34;color:#66d9ef&#34;&gt;condition&lt;/span&gt;: bucketrepo.enabled
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: bucketrepo
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: jenkins-x-platform
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Using a yaml file in a boot config repo we list the apps that should be installed.  This means we can instead have a bare minimum base boot config repo and list the apps we want installed and different points of the installation process.&lt;/p&gt;
&lt;p&gt;The above YAML looks quite like the &lt;code&gt;env/requirements.yaml&lt;/code&gt; file only:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it allows the &lt;code&gt;namespace&lt;/code&gt; to be specified if its different from the &lt;code&gt;defaultNamespace&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;we add the &lt;code&gt;phase&lt;/code&gt; label so that we can filter the apps by phase so we can install different charts at different points in the boot pipeline.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;### Strawman Solutions&lt;/p&gt;
&lt;p&gt;The above &lt;code&gt;apps.yaml&lt;/code&gt; proposal looks very much like helmfile.&lt;/p&gt;
&lt;p&gt;So lets look into helmfile and try using it with a stripped back boot config repo to see how things might fit together&lt;/p&gt;
&lt;p&gt;One possible solution might be to add a single step the boot pipeline to invoke helmfile: &lt;a href=&#34;https://github.com/roboll/helmfile#configuration&#34;&gt;https://github.com/roboll/helmfile#configuration&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;e.g. given the &lt;code&gt;apps.yaml&lt;/code&gt; file in the file system then run helmfile as a step on the file.&lt;/p&gt;
&lt;p&gt;It looks like helmfile already supports tillerless + helm3 and lets us define namespaces and orders etc.&lt;/p&gt;
&lt;p&gt;We may need to build our own step to wrap helmfile so that we can do some of the things we do with &lt;code&gt;jx step helm apply&lt;/code&gt; right now (e.g. exposing the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file as a &lt;code&gt;values.yaml&lt;/code&gt; its values can be used inside any &lt;code&gt;values.yaml&lt;/code&gt; we use in the charts).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;should we support access to secrets in vault / local file system via URLs or Parameters injection?&lt;/li&gt;
&lt;li&gt;do we need to support exposing the properties from the &lt;code&gt;jx-requirements.yml&lt;/code&gt; as values.yaml files that can be reused inside the helmfile templates?&lt;/li&gt;
&lt;li&gt;do we need to improve access to certs / domain after we&amp;rsquo;ve set those up in boot?&lt;/li&gt;
&lt;li&gt;allow the use of version streams to manage versions of things if no version is specified in the &lt;code&gt;helmfile.yaml&lt;/code&gt; - like we do with helm charts requirements.yaml file right now (in &lt;code&gt;jx step helm apply&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So if we do need anything other than vanilla helmfile we could maybe do a similar thing to &lt;code&gt;jx step helm apply&lt;/code&gt; where we copy the directory where helmfile lives, then generate any secret yamls + &lt;code&gt;jx-requirements.yaml&lt;/code&gt; files and then run helmfile in a temporary directory (to avoid accidentally committing any secrets to git). Hopefully we don&amp;rsquo;t need to fork helmfile; but we could just wrap it slightly with a pre-processor?&lt;/p&gt;
&lt;p&gt;We want to allow the &lt;code&gt;jx boot&lt;/code&gt; pipeline to invoke a helmfile like thing at the different phases.&lt;/p&gt;
&lt;p&gt;e.g. currently in boot we do something like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;install a bunch of charts in different namespaces with a defined order&lt;/li&gt;
&lt;li&gt;then we modify the requirements based on ingress: &lt;code&gt;jx step create install values&lt;/code&gt; (to handle things like detecting the domain/ingress)&lt;/li&gt;
&lt;li&gt;install more charts (e.g. external dns/cert manager/vault)&lt;/li&gt;
&lt;li&gt;populate parameters/secrets (&lt;code&gt;jx step create values --name parameters&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;do the traditional install and maybe other charts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so we already have 3 natural places to invoke a helmfile-like thing to install charts in different phases. So maybe thats 3 places where we invoke helmfile with a selector as @vbehar mentions if thats something helmfile can do? or we use 3 separate helmfiles maybe?&lt;/p&gt;
&lt;p&gt;e.g. the pipeline with boot apps could be something like this&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx step helmfile --selector phase=pre-ingress

# populate ingress stuff (e.g. default domain from nip.io if not using custom domain)
jx step create install values

# add any charts that need a domain injected
jx step helmfile --selector phase=post-ingress


# populate any missing charts in vault
jx step create values --name parameters

# lets include generated secrets after they have been populated in vault
jx step helmfile --selector &amp;quot;!phase&amp;quot; --secrets
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we could have a list of apps which we group as to where they get added based on what they are &amp;amp; whether they need integration with secrets / TLS / domain / certs etc?&lt;/p&gt;
&lt;p&gt;We can then modify the existing &lt;code&gt;jx add app / jx delete app&lt;/code&gt; to detect the &lt;code&gt;apps.yaml&lt;/code&gt; file and create the necessary code change in a Pull Request.&lt;/p&gt;
&lt;p&gt;Maybe over time we move more towards this kind of helmfile-like approach for all environments too (&lt;code&gt;Dev&lt;/code&gt; / &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt;)?&lt;/p&gt;
&lt;h3 id=&#34;proposed-schedule&#34;&gt;Proposed Schedule&lt;/h3&gt;
&lt;p&gt;We can easily try a prototype a new boot config repo where we add helmfile and add some helmfile steps and see how it works and what we think of the general git source code &amp;amp; if it helps us and users have modular boot apps without committing to any significant changes in the jx repos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;try out helmfile for installing things like gloo / knative / linkerd / istio?&lt;/li&gt;
&lt;li&gt;if that works and we are happy with it, we could look at adding the phases approach for easier app composition&lt;/li&gt;
&lt;li&gt;if thats all looking good try migrate existing things like nginx / cert manager / external dns to the helmfile approach in a new git repository&lt;/li&gt;
&lt;li&gt;anyone can then try out the helmfile approach without changing the core upstream boot configuration &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/tree/master/env&#34;&gt;jenkins-x-boot-config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;we could try create a new remote cluster boot configuration for multi-cluster which installs a small subset of Jenkins X (e.g. lighthouse + tekton + a single &lt;code&gt;SourceRepository + Schedule&lt;/code&gt; for replicating the logic of the &lt;code&gt;environment controller&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;create a demo repository which replaces nginx-controller with knative + gloo we can use for Progressive Delivery demos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Maybe we find when we look at migrating the current charts to boot apps (nginx / cert manager / external-dns in particular) we may find its got some limitations and building a simple similar tool might be easier. Or we may find helmfile gets us where we need to go faster.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: How it works</title>
      <link>https://jenkins-x.io/docs/v3/about/how-it-works/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jenkins-x.io/docs/v3/about/how-it-works/</guid>
      <description>
        
        
        &lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;
&lt;p&gt;The GitOps repository templates contain the source code, scripts and docs to help you get your cloud resources created (e.g. a kubernetes cluster and maybe buckets and/or a secret manager).&lt;/p&gt;
&lt;p&gt;Once you have created the GitOps repository from one of the &lt;a href=&#34;https://jenkins-x.io/docs/v3/getting-started/&#34;&gt;available templates and followed the instructions&lt;/a&gt; to set up your infrastructure you &lt;a href=&#34;https://jenkins-x.io/docs/v3/guides/operator/&#34;&gt;install the git operator&lt;/a&gt; via the  via &lt;a href=&#34;https://github.com/jenkins-x/jx-admin/blob/master/docs/cmd/jx-admin_operator.md&#34;&gt;jx admin operator&lt;/a&gt; command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    jx admin operator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;That command essentially installs the &lt;a href=&#34;https://github.com/jenkins-x/jx-git-operator&#34;&gt;git operator&lt;/a&gt; chart, passing in the git URL, username and token to run the boot process&lt;/p&gt;
&lt;h3 id=&#34;git-operator&#34;&gt;Git Operator&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/jenkins-x/jx-git-operator&#34;&gt;git operator&lt;/a&gt; works by polling the git repository looking for changes and running a kubernetes Job on each change. The Job resource is defined inside the git repository at &lt;strong&gt;.jx/git-operator/job.yaml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You can view the boot Job log via the command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    jx admin log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Or you can browse the log in the Octant UI in the operations tab.&lt;/p&gt;
&lt;h3 id=&#34;boot-job&#34;&gt;Boot Job&lt;/h3&gt;
&lt;p&gt;The boot job runs on startup and on any git commit to the GitOps repository you used to install the operator.&lt;/p&gt;
&lt;p&gt;The boot job is defined in &lt;strong&gt;.jx/git-operator/job.yaml&lt;/strong&gt; in git and essentially:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Runs the generate step&lt;/li&gt;
&lt;li&gt;Runs the apply step&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;generate-step&#34;&gt;Generate step&lt;/h4&gt;
&lt;p&gt;This step is run in the following situations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On startup&lt;/li&gt;
&lt;li&gt;After each commit in a Pull Request&lt;/li&gt;
&lt;li&gt;Whenever a commit is made to the main branch which isn’t a merge of a Pull Request merge&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The generate step does the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resolves any missing values (cluster information, domain name) in the &lt;strong&gt;jx-values.yaml&lt;/strong&gt; file&lt;/li&gt;
&lt;li&gt;Resolves any missing versions or helm values.yaml files the &lt;strong&gt;helmfile.yaml&lt;/strong&gt; file&lt;/li&gt;
&lt;li&gt;Runs &lt;code&gt;helmfile template&lt;/code&gt; to generate the kubernetes resources for all the charts&lt;/li&gt;
&lt;li&gt;Copy all the generated resources into a tree of files in &lt;strong&gt;config-root/namespaces/myns/somechart/*.yaml&lt;/strong&gt; where
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;myns&lt;/strong&gt; is the namespace for the resources&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Somechart&lt;/strong&gt; is the name of the chart (or chart alias)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Any &lt;strong&gt;Secret&lt;/strong&gt; resource is converted to an &lt;strong&gt;ExternalSecret&lt;/strong&gt; so that it can be checked into git&lt;/li&gt;
&lt;li&gt;A few extra steps are run on the YAMLs to help deployments
&lt;ul&gt;
&lt;li&gt;Add a common label so that kubectl apply &amp;ndash;prune &amp;ndash;selector can be used&lt;/li&gt;
&lt;li&gt;Add some hashes to resources so that changes to configurations causes a rolling upgrade&lt;/li&gt;
&lt;li&gt;Add support for the &lt;a href=&#34;https://github.com/pusher/wave&#34;&gt;pusher wave&lt;/a&gt; operator so that changing of secret values (inside, say, vault or Amazon/Azure/Google secret manager) causes a rolling upgrade of pods.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;apply-step&#34;&gt;Apply step&lt;/h4&gt;
&lt;p&gt;This step is run on any commit to the main branch(after the generate step has completed).&lt;/p&gt;
&lt;p&gt;It essentially does &lt;code&gt;kubectl apply&lt;/code&gt; of the resources in the &lt;strong&gt;config-root&lt;/strong&gt; tree in git.&lt;/p&gt;
&lt;p&gt;The apply step could be performed by other tools if need be (e.g. Google Anthos Config Sync or flux).&lt;/p&gt;
&lt;h3 id=&#34;promotion&#34;&gt;Promotion&lt;/h3&gt;
&lt;p&gt;When you create a quickstart or import a new project a new release is created then promotion is triggered just like in Jenkins X 2.x.&lt;/p&gt;
&lt;p&gt;One change from Jenkins X 2.x is we default to including the specific kubernetes resources in git; rather than, say, just the name of a helm chart and the version.&lt;/p&gt;
&lt;p&gt;So what tends to happen is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the promote step in a pipeline creates a Pull Request on the GitOps repository for the cluster to add or upgrade a helm chart and version&lt;/li&gt;
&lt;li&gt;The above Generate and Apply steps run to fill in more details to the Pull Request of the actual kubernetes resources that will be added, modified or removed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So you will see 2 commits on a typical promotion pull request; the high level change of the helm chart(s) and versions then the detail of the actual changes that will apply to kubernetes.&lt;/p&gt;
&lt;h2 id=&#34;comparison-to-2x&#34;&gt;Comparison to 2.x&lt;/h2&gt;
&lt;p&gt;From a high level Jenkins X 3.x similar to 2.x in that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We use GitOps to manage applications, configurations and versions; keeping everything but secret values in git&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However we’ve made a few changes in 3.x:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We have a &lt;a href=&#34;https://jenkins-x.io/docs/v3/getting-started/&#34;&gt;simpler UX now for setting up Jenkins X&lt;/a&gt; which uses a library of GitOps repository templates you can start from
&lt;ul&gt;
&lt;li&gt;This lets you choose the closest example to the kind of infrastructure, tools and secret store you want to use so it’s easier to get started if your requirements fit the common quickstarts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The setup/install/upgrade process runs inside kubernetes rather than on a developers laptop
&lt;ul&gt;
&lt;li&gt;This avoids all kinds of issues with different installations of tools like git, kubectl, helm etc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In 2.x we always had a git repository for Dev, Staging and Production. In 3.x if those environments are all inside the same cluster we use the same git repository for configuring cluster level resources and resources in any namespaces.
&lt;ul&gt;
&lt;li&gt;So by default there is 1 git repository with Jenkins X 3.x for the installation&lt;/li&gt;
&lt;li&gt;Whenever you create separate clusters (e.g. for muticluster support and you want Staging / Production environments to be separate), then each cluster gets its own git repository.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
