<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins X – Contribute to the Jenkins X Project</title>
    <link>/docs/contributing/</link>
    <description>Recent content in Contribute to the Jenkins X Project on Jenkins X</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="/docs/contributing/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Contribute to the code</title>
      <link>/docs/contributing/code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/contributing/code/</guid>
      <description>
        
        
        

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Jenkins X is an open-source project and lives by the work of its &lt;a href=&#34;https://github.com/jenkins-x/jx/graphs/contributors&#34; target=&#34;_blank&#34;&gt;contributors&lt;/a&gt;. There are plenty of &lt;a href=&#34;https://github.com/jenkins-x/jx/issues&#34; target=&#34;_blank&#34;&gt;open issues&lt;/a&gt;, and we need your help to make Jenkins X even more awesome. You don&amp;rsquo;t need to be a Go guru to contribute to the project&amp;rsquo;s development.&lt;/p&gt;

&lt;h1 id=&#34;assumptions&#34;&gt;Assumptions&lt;/h1&gt;

&lt;p&gt;This contribution guide takes a step-by-step approach in hopes of helping newcomers. Therefore, we only assume the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You are new to Git or open-source projects in general&lt;/li&gt;
&lt;li&gt;You are a fan of Jenkins X and enthusiastic about contributing to the project&lt;/li&gt;
&lt;/ul&gt;



&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;

If you&amp;rsquo;re struggling at any point in this contribution guide, reach out to the Jenkins X community in &lt;a href=&#34;/community/&#34;&gt;Jenkins X&amp;rsquo;s Discussion forum&lt;/a&gt;.
&lt;/div&gt;


&lt;h1 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h1&gt;

&lt;p&gt;To contribute to Jenkins X jx binary, you will need:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com&#34; target=&#34;_blank&#34;&gt;Git&lt;/a&gt; and a &lt;a href=&#34;https://github.com&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt; account&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;Go&lt;/a&gt; &lt;code&gt;1.11.4&lt;/code&gt;, with support for compiling to &lt;code&gt;linux/amd64&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://pre-commit.com/#install&#34; target=&#34;_blank&#34;&gt;pre-commit&lt;/a&gt; - once installed, ensure you&amp;rsquo;re at the root of the repository which contains a &lt;code&gt;.pre-commit-config.yaml&lt;/code&gt; configuration file, then:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pre-commit install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;install-go&#34;&gt;Install Go&lt;/h2&gt;

&lt;p&gt;We recommend the latest version of go &lt;code&gt;1.11.4&lt;/code&gt; as this ensures the go modules works.&lt;/p&gt;

&lt;p&gt;The installation of Go should take only a few minutes. You have more than one option to get Go up and running on your machine.&lt;/p&gt;

&lt;p&gt;If you are having trouble following the installation guides for go, check out &lt;a href=&#34;http://www.golangbootcamp.com/book/get_setup&#34; target=&#34;_blank&#34;&gt;Go Bootcamp&lt;/a&gt; which contains setups for every platform or reach out to the Jenkins X community in the &lt;a href=&#34;/community/#slack&#34;&gt;Jenkins X Slack channels&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;install-go-on-macos&#34;&gt;Install Go on macOS&lt;/h3&gt;

&lt;p&gt;If you are a macOS user and have &lt;a href=&#34;https://brew.sh/&#34; target=&#34;_blank&#34;&gt;Homebrew&lt;/a&gt; installed on your machine, installing Go is as simple as the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ brew install go
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-go-via-gvm&#34;&gt;Install Go via GVM&lt;/h3&gt;

&lt;p&gt;More experienced users can use the &lt;a href=&#34;https://github.com/moovweb/gvm&#34; target=&#34;_blank&#34;&gt;Go Version Manager&lt;/a&gt; (GVM). GVM allows you to switch between different Go versions &lt;em&gt;on the same machine&lt;/em&gt;. If you&amp;rsquo;re a beginner, you probably don&amp;rsquo;t need this feature. However, GVM makes it easy to upgrade to a new released Go version with just a few commands.&lt;/p&gt;

&lt;p&gt;GVM comes in especially handy if you follow the development of Jenkins X over a longer period of time. Future versions of Jenkins X will usually be compiled with the latest version of Go. Sooner or later, you will have to upgrade if you want to keep up.&lt;/p&gt;

&lt;h3 id=&#34;install-go-on-windows&#34;&gt;Install Go on Windows&lt;/h3&gt;

&lt;p&gt;Simply install the latest version by downloading the &lt;a href=&#34;https://golang.org/dl/&#34; target=&#34;_blank&#34;&gt;installer&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;clearing-your-go-module-cache&#34;&gt;Clearing your go module cache&lt;/h2&gt;

&lt;p&gt;If you have used an older version of go you may have old versions of go modules. So its good to run this command to clear your cache if you are having go build issues:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go clean -modcache
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set-up-your-gopath&#34;&gt;Set up your GOPATH&lt;/h3&gt;

&lt;p&gt;Once you&amp;rsquo;re finished installing Go, let&amp;rsquo;s confirm everything is working correctly. Open a terminal - or command line under Windows - and type the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see something similar to the following written to the console (on macOS). Note that the version here reflects the most recent version of Go as of the last update for this page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go version go1.11 darwin/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, make sure that you set up your &lt;code&gt;GOPATH&lt;/code&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/SettingGOPATH&#34; target=&#34;_blank&#34;&gt;as described in the installation guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can print the &lt;code&gt;GOPATH&lt;/code&gt; with &lt;code&gt;echo $GOPATH&lt;/code&gt;. You should see a non-empty string containing a valid path to your Go workspace; .e.g.:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ echo $GOPATH
/Users/&amp;lt;yourusername&amp;gt;/Code/go
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-git-on-your-system&#34;&gt;Install Git on your system&lt;/h2&gt;

&lt;p&gt;Git is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Version_control&#34; target=&#34;_blank&#34;&gt;version control system&lt;/a&gt; to track the changes of source code.&lt;/p&gt;

&lt;p&gt;You will need to have Git installed on your computer to contribute to Jenkins X development. Teaching Git is outside the scope of the Jenkins X docs, but if you&amp;rsquo;re looking for an excellent reference to learn the basics of Git, we recommend the &lt;a href=&#34;https://git-scm.com/book/&#34; target=&#34;_blank&#34;&gt;Git book&lt;/a&gt; if you are not sure where to begin.&lt;/p&gt;

&lt;p&gt;Move back to the terminal and check if Git is already installed. Type in &lt;code&gt;git version&lt;/code&gt; and press enter. You can skip the rest of this section if the command returned a version number. Otherwise &lt;a href=&#34;https://git-scm.com/downloads&#34; target=&#34;_blank&#34;&gt;download&lt;/a&gt; the latest version and follow this &lt;a href=&#34;https://git-scm.com/book/en/v2/Getting-Started-Installing-Git&#34; target=&#34;_blank&#34;&gt;installation guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, check again with &lt;code&gt;git version&lt;/code&gt; if Git was installed successfully.&lt;/p&gt;

&lt;h3 id=&#34;git-graphical-front-ends&#34;&gt;Git Graphical Front Ends&lt;/h3&gt;

&lt;p&gt;There are several &lt;a href=&#34;https://git-scm.com/downloads/guis&#34; target=&#34;_blank&#34;&gt;GUI clients&lt;/a&gt; that help you to operate Git. Not all are available for all operating systems and maybe differ in their usage. Thus, we will use the command line since the commands are everywhere the same.&lt;/p&gt;

&lt;h3 id=&#34;install-hub-on-your-system-optional&#34;&gt;Install Hub on Your System (Optional)&lt;/h3&gt;

&lt;p&gt;Hub is a great tool for working with GitHub. The main site for it is &lt;a href=&#34;https://hub.github.com/&#34; target=&#34;_blank&#34;&gt;hub.github.com&lt;/a&gt;. Feel free to install this little Git wrapper.&lt;/p&gt;

&lt;p&gt;On a Mac, you can install &lt;a href=&#34;https://github.com/github/hub&#34; target=&#34;_blank&#34;&gt;Hub&lt;/a&gt; using &lt;a href=&#34;https://brew.sh&#34; target=&#34;_blank&#34;&gt;Homebrew&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ brew install hub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ll create an &lt;a href=&#34;http://tldp.org/LDP/abs/html/aliases.html&#34; target=&#34;_blank&#34;&gt;alias in Bash&lt;/a&gt; so that typing &lt;code&gt;git&lt;/code&gt; actually runs &lt;code&gt;Hub&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ echo &amp;quot;alias git=&#39;hub&#39;&amp;quot; &amp;gt;&amp;gt; ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;create-a-github-account&#34;&gt;Create a GitHub Account&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re going to contribute code, you&amp;rsquo;ll need to have an account on GitHub. Go to &lt;a href=&#34;https://github.com/join&#34; target=&#34;_blank&#34;&gt;www.github.com/join&lt;/a&gt; and set up a personal account.&lt;/p&gt;

&lt;h2 id=&#34;set-up-your-working-copy&#34;&gt;Set up your working copy&lt;/h2&gt;

&lt;p&gt;The working copy is set up locally on your computer. It&amp;rsquo;s what you&amp;rsquo;ll edit, compile, and end up pushing back to GitHub. The main steps are cloning the repository and creating your fork as a remote.&lt;/p&gt;

&lt;h3 id=&#34;fork-the-repository&#34;&gt;Fork the repository&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;re not familiar with this term, GitHub&amp;rsquo;s &lt;a href=&#34;https://help.github.com/articles/fork-a-repo/&#34; target=&#34;_blank&#34;&gt;help pages&lt;/a&gt; provide again a simple explanation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A fork is a copy of a repository. Forking a repository allows you to freely experiment with changes without affecting the original project.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Open the &lt;a href=&#34;https://github.com/jenkins-x/jx&#34; target=&#34;_blank&#34;&gt;Jenkins X repository&lt;/a&gt; on GitHub and click on the &amp;ldquo;Fork&amp;rdquo; button in the top right.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/contribute/development/forking-a-repository.png&#34; alt=&#34;Fork button&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;clone-your-fork-locally&#34;&gt;Clone your fork locally&lt;/h3&gt;

&lt;p&gt;Now open your fork repository on GitHub and copy the remote url of your fork. You can choose between HTTPS and SSH as protocol that Git should use for the following operations. HTTPS works always &lt;a href=&#34;https://help.github.com/articles/which-remote-url-should-i-use/&#34; target=&#34;_blank&#34;&gt;if you&amp;rsquo;re not sure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/contribute/development/copy-remote-url.png&#34; alt=&#34;Copy remote url&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then go back to your terminal and clone your fork locally. Since jx is a Go package, it should be located at &lt;code&gt;$GOPATH/src/github.com/jenkins-x/jx&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir -p $GOPATH/src/github.com/jenkins-x
$ cd $GOPATH/src/github.com/jenkins-x
$ git clone git@github.com:&amp;lt;username&amp;gt;/jx.git
$ cd jx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add the conventional upstream &lt;code&gt;git&lt;/code&gt; remote in order to fetch changes from jx&amp;rsquo;s main master
branch and to create pull requests:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git remote add upstream https://github.com/jenkins-x/jx.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s check if everything went right by listing all known remotes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git remote -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output should look similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;digitalcraftsman    git@github.com:digitalcraftsman/jx.git (fetch)
digitalcraftsman    git@github.com:digitalcraftsman/jx.git (push)
origin  https://github.com/jenkins-x/jx (fetch)
origin  https://github.com/jenkins-x/jx (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fork-with-hub&#34;&gt;Fork with Hub&lt;/h3&gt;

&lt;p&gt;Alternatively, you can use the Git wrapper Hub. Hub makes forking a repository easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hub fork
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That command will log in to GitHub using your account, create a fork of the repository that you&amp;rsquo;re currently working in, and add it as a remote to your working copy.&lt;/p&gt;

&lt;h2 id=&#34;contribution-workflow&#34;&gt;Contribution Workflow&lt;/h2&gt;

&lt;h3 id=&#34;create-a-new-branch&#34;&gt;Create a new branch&lt;/h3&gt;

&lt;p&gt;First, ensure that your local repository is up-to-date with the latest version of jx. More details on &lt;a href=&#34;https://help.github.com/articles/syncing-a-fork/&#34; target=&#34;_blank&#34;&gt;GitHub help&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git fetch upstream
$ git checkout master
$ git merge upstream/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can create a new branch for your change:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git checkout -b &amp;lt;BRANCH-NAME&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can check on which branch your are with &lt;code&gt;git branch&lt;/code&gt;. You should see a list of all local branches. The current branch is indicated with a little asterisk.&lt;/p&gt;

&lt;h3 id=&#34;general-development&#34;&gt;General Development&lt;/h3&gt;

&lt;h4 id=&#34;cross-platform-development&#34;&gt;Cross-platform Development&lt;/h4&gt;

&lt;p&gt;Bear in mind when developing that the code can (and will) run on different architectures/operating systems from your own. You may develop on a *nix platform, but other users will also be using Windows. Keep other platforms in mind when developing your code, eg:
* Not all platforms use the &lt;code&gt;HOME&lt;/code&gt; environment variable for your home directory. Use &lt;a href=&#34;https://golang.org/pkg/os/user/#Current&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;user.Current&lt;/code&gt;&lt;/a&gt;&lt;a href=&#34;https://golang.org/pkg/os/user/#User&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;.HomeDir&lt;/code&gt;&lt;/a&gt; instead of looking up &lt;code&gt;$HOME&lt;/code&gt; to get the user&amp;rsquo;s home directory
* Different platforms use different places for temporary directories/files. Use &lt;a href=&#34;https://golang.org/pkg/io/ioutil/#TempDir&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;ioutil.TempDir&lt;/code&gt;&lt;/a&gt; instead of creating directories/files under &lt;code&gt;/tmp&lt;/code&gt;
* Be aware of path separators (*nix uses &lt;code&gt;/&lt;/code&gt;, Windows uses &lt;code&gt;\&lt;/code&gt;) - do not just concantenate strings when using filepaths; instead use &lt;a href=&#34;https://golang.org/pkg/path/filepath/#Join&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;filepath.Join&lt;/code&gt;&lt;/a&gt; to concatenate file paths safely
* Be aware of default line endings (*nix uses &lt;code&gt;LF&lt;/code&gt;, Windows uses &lt;code&gt;CRLF&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&#34;push-commits&#34;&gt;Push commits&lt;/h3&gt;

&lt;p&gt;To push our commits to the fork on GitHub you need to specify a destination. A destination is defined by the remote and a branch name. Earlier, you defined that the remote url of our fork is the same as our GitHub handle, in this case &lt;code&gt;digitalcraftsman&lt;/code&gt;. The branch should have the same as our local one. This makes it easy to identify corresponding branches.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git push --set-upstream origin &amp;lt;BRANCH-NAME&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now Git knows the destination. Next time when you to push commits you just need to enter &lt;code&gt;git push&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;build-your-change&#34;&gt;Build your change&lt;/h3&gt;

&lt;p&gt;With the prerequisites installed and your fork of jx cloned, you can make changes to local jx source code and hack as much as you want.&lt;/p&gt;

&lt;p&gt;Run &lt;code&gt;make&lt;/code&gt; to build the &lt;code&gt;jx&lt;/code&gt; binaries:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ make build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See below to get some advises on how to &lt;a href=&#34;#testing&#34;&gt;test&lt;/a&gt; and &lt;a href=&#34;#debugging&#34;&gt;debug&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;squash-and-rebase&#34;&gt;Squash and rebase&lt;/h3&gt;

&lt;p&gt;So you are happy with your development and are ready to prepare the PR. Before going further, let&amp;rsquo;s squash and rebase your work.&lt;/p&gt;

&lt;p&gt;This is a bit more advanced but required to ensure a proper Git history of Jenkins X. Git allows you to &lt;a href=&#34;https://git-scm.com/docs/git-rebase&#34; target=&#34;_blank&#34;&gt;rebase&lt;/a&gt; commits. In other words: it allows you to rewrite the commit history.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take an example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git rebase --interactive @~3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;3&lt;/code&gt; at the end of the command represents the number of commits that should be modified. An editor should open and present a list of last three commit messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick 911c35b Add &amp;quot;How to contribute to Jenkins X&amp;quot; tutorial
pick 33c8973 Begin workflow
pick 3502f2e Refactoring and typo fixes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the case above we should merge the last 2 commits in the commit of this tutorial (&lt;code&gt;Add &amp;quot;How to contribute to Jenkins X&amp;quot; tutorial&lt;/code&gt;). You can &amp;ldquo;squash&amp;rdquo; commits, i.e. merge two or more commits into a single one.&lt;/p&gt;

&lt;p&gt;All operations are written before the commit message. Replace &lt;code&gt;pick&lt;/code&gt; with an operation. In this case &lt;code&gt;squash&lt;/code&gt; or &lt;code&gt;s&lt;/code&gt; for short:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick 911c35b Add &amp;quot;How to contribute to Jenkins X&amp;quot; tutorial
squash 33c8973 Begin workflow
squash 3502f2e Refactoring and typo fixes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also want to rewrite the commits message of the third last commit. We forgot &amp;ldquo;docs:&amp;rdquo; as prefix according to the code contribution guidelines. The operation to rewrite a commit is called &lt;code&gt;reword&lt;/code&gt; (or &lt;code&gt;r&lt;/code&gt; as shortcut).&lt;/p&gt;

&lt;p&gt;You should end up with a similar setup:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reword 911c35b Add &amp;quot;How to contribute to Jenkins X&amp;quot; tutorial
squash 33c8973 Begin workflow
squash 3502f2e Refactoring and typo fixes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Close the editor. It should open again with a new tab. A text is instructing you to define a new commit message for the last two commits that should be merged (aka &amp;ldquo;squashed&amp;rdquo;). Save the file and close the editor again.&lt;/p&gt;

&lt;p&gt;A last time a new tab opens. Enter a new commit message and save again. Your terminal should contain a status message. Hopefully this one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Successfully rebased and updated refs/heads/&amp;lt;BRANCH-NAME&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the commit log if everything looks as expected. Should an error occur you can abort this rebase with &lt;code&gt;git rebase --abort&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In case you already pushed your work to your fork, you need to make a force push&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git push --force
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last step, to ensure that your change would not conflict with other changes done in parallel by other contributors, you need to rebase your work on the latest changes done on jx master branch. Simply:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git checkout master #Move to local master branch
$ git fetch upstream #Retrieve change from jx master bracnch
$ git merge upstream/master #Merge the change into your local master
$ git checkout &amp;lt;BRANCH-NAME&amp;gt; #Move back to your local branch where you did your development
$ git rebase master

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Handle any conflicts and make sure your code builds and all tests pass. Then force push your branch to your remote.&lt;/p&gt;

&lt;h2 id=&#34;signoff&#34;&gt;Signoff&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Developer_Certificate_of_Origin&#34; target=&#34;_blank&#34;&gt;Developer Certificate of Origin&lt;/a&gt; is required for all
commits. It can be proivided using the &lt;a href=&#34;https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---signoff&#34; target=&#34;_blank&#34;&gt;signoff&lt;/a&gt;
option for &lt;code&gt;git commit&lt;/code&gt; or by GPG signing the commit. The developer certificate is available at (&lt;a href=&#34;https://developercertificate.org/&#34; target=&#34;_blank&#34;&gt;https://developercertificate.org/&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Jenkins X enforces the DCO using the a &lt;a href=&#34;https://github.com/probot/dco&#34; target=&#34;_blank&#34;&gt;bot&lt;/a&gt;. You can view the details on the DCO check
by viewing the &lt;code&gt;Checks&lt;/code&gt; tab in the GitHub pull request.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/13410355/42352794-85fe1c9c-8071-11e8-834a-05a4aeb8cc90.png&#34; alt=&#34;DCO signoff check&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can use a hook to make sure all your commits messages are signed off.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Run &lt;code&gt;mkdir -p ~/.git-templates/hooks&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;git config --global init.templatedir ~/.git-templates&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add this to &lt;code&gt;~/.git-templates/hooks/prepare-commit-msg&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

COMMIT_MSG_FILE=$1  # The git commit file.
COMMIT_SOURCE=$2    # The current commit message.

# Add &amp;quot;Signed-off-by: &amp;lt;user&amp;gt; &amp;lt;email&amp;gt;&amp;quot; to every commit message.
SOB=$(git var GIT_COMMITTER_IDENT | sed -n &#39;s/^\(.*&amp;gt;\).*$/Signed-off-by: \1/p&#39;)
git interpret-trailers --in-place --trailer &amp;quot;$SOB&amp;quot; &amp;quot;$COMMIT_MSG_FILE&amp;quot;
if test -z &amp;quot;$COMMIT_SOURCE&amp;quot;; then
/usr/bin/perl -i.bak -pe &#39;print &amp;quot;\n&amp;quot; if !$first_line++&#39; &amp;quot;$COMMIT_MSG_FILE&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Make sure this file executable &lt;code&gt;chmod u+x ~/.git-templates/hooks/prepare-commit-msg&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Run &lt;code&gt;git init&lt;/code&gt; on the repo you want to use the hook on&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that this will not override the hooks already defined on your local repo. It adds the &lt;code&gt;Signed-off-by: ...&lt;/code&gt; line
after the commit message has been created by the user.&lt;/p&gt;

&lt;p&gt;A better alternative is to GPG sign all your commits. This has the advantage that as well as stating your agreement to
the DCO it also creates a trust mechanism for your commits. It&amp;rsquo;s a little harder to set up but there is a
good guide from GitHub:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If you don&amp;rsquo;t already have a GPG key then follow &lt;a href=&#34;https://help.github.com/en/articles/generating-a-new-gpg-key&#34; target=&#34;_blank&#34;&gt;this guide to create one&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Now you have a GPG key follow &lt;a href=&#34;https://help.github.com/en/articles/signing-commits&#34; target=&#34;_blank&#34;&gt;this guide to see how to sign your commit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Next, tell &lt;a href=&#34;https://help.github.com/en/articles/adding-a-new-gpg-key-to-your-github-account&#34; target=&#34;_blank&#34;&gt;tell GitHub about your key so that it can verify your commits&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now, configure git to always use sign commits by running&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git config --global user.signingkey &amp;lt;key id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The process to find the key id is described in &lt;a href=&#34;https://help.github.com/en/articles/checking-for-existing-gpg-keys&#34; target=&#34;_blank&#34;&gt;https://help.github.com/en/articles/checking-for-existing-gpg-keys&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Set up a keychain for your platform. This is entirely optional but means you don&amp;rsquo;t need to type your passphrase every
time and allows git to run headless. If you are using a Mac GPG Suite is a good way to do this. If you are on another
platform please open a PR against this document and add your recommendations!&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;the-commit-message&#34;&gt;The commit message&lt;/h2&gt;

&lt;p&gt;Jenkins X uses &lt;a href=&#34;https://www.conventionalcommits.org/en/v1.0.0-beta.4/&#34; target=&#34;_blank&#34;&gt;conventional commits&lt;/a&gt; as it&amp;rsquo;s commit message format. These are particularly important as semantic releases are in use, and they use the commit messages to determine the type of changes in the codebase. Following formalized conventions for commit messages the semantic release automatically determines the next &lt;a href=&#34;https://semver.org&#34; target=&#34;_blank&#34;&gt;semantic version&lt;/a&gt; number and generates a changelog based on the conventional commit.&lt;/p&gt;

&lt;p&gt;Semantic releases originate in the &lt;a href=&#34;https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines&#34; target=&#34;_blank&#34;&gt;Angular Commit Message Conventions&lt;/a&gt;, and the rules described there are the ones used by Jenkins X.&lt;/p&gt;

&lt;p&gt;Here is an example of the release type that will be done based on a commit messages:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Commit message&lt;/th&gt;
&lt;th&gt;Release type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fix(pencil): stop graphite breaking when too much pressure applied&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Patch Release&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;feat(pencil): add &#39;graphiteWidth&#39; option&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;del&gt;Minor&lt;/del&gt; Feature Release&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;perf(pencil): remove graphiteWidth option&lt;/code&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;BREAKING CHANGE: The graphiteWidth option has been removed.&lt;/code&gt;&lt;br&gt;&lt;code&gt;The default graphite width of 10mm is always used for performance reasons.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;del&gt;Major&lt;/del&gt; Breaking Release&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;open-a-pull-request&#34;&gt;Open a pull request&lt;/h2&gt;

&lt;p&gt;We made a lot of progress. Good work. In this step we finally open a pull request to submit our additions. Open the &lt;a href=&#34;https://github.com/jenkins-x/jx/&#34; target=&#34;_blank&#34;&gt;Jenkins X master repository&lt;/a&gt; on GitHub in your browser.&lt;/p&gt;

&lt;p&gt;You should find a green button labeled with &amp;ldquo;New pull request&amp;rdquo;. But GitHub is clever and probably suggests you a pull request like in the beige box below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/contribute/development/open-pull-request.png&#34; alt=&#34;Open a pull request&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The new page summaries the most important information of your pull request. Scroll down and you find the additions of all your commits. Make sure everything looks as expected and click on &amp;ldquo;Create pull request&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;There are a number of automated checks that will run on your PR:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Semantic Pull Request - validates that your commit messages meet the Conventional Commit format described above.
Additionally your PR must also have a conventional message. The UX for this bot is a little odd as it doesn&amp;rsquo;t go red
if the messages are NOT correct, instead it goes yellow. You need it to go to a green tick!&lt;/li&gt;
&lt;li&gt;DCO - see &lt;a href=&#34;#Signoff&#34;&gt;Signoff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hound - lints the code and comments inline with any issues. You need this to go to a green tick and and say &amp;ldquo;No violations found. Woof!&amp;rdquo;&lt;/li&gt;
&lt;li&gt;lint - runs a lot more lint checks but in a CI job so won&amp;rsquo;t provide inline feedback. You need this to pass as a green tick. Check the log for any errors.&lt;/li&gt;
&lt;li&gt;bdd - runs the end to end test &lt;a href=&#34;https://github.com/jenkins-x/bdd-jx/blob/master/test/spring/jx_create_spring.go&#34; target=&#34;_blank&#34;&gt;create-spring&lt;/a&gt; in a new team on an existing cluster using static jenkins. Check the logs for errors.&lt;/li&gt;
&lt;li&gt;tekton - runs the end to end test &lt;a href=&#34;https://github.com/jenkins-x/bdd-jx/blob/master/test/spring/jx_create_spring.go&#34; target=&#34;_blank&#34;&gt;create-spring&lt;/a&gt;, &lt;a href=&#34;https://github.com/jenkins-x/bdd-jx/blob/master/test/quickstart/helpers.go#L50&#34; target=&#34;_blank&#34;&gt;test-quickstart-golang-http&lt;/a&gt; and &lt;a href=&#34;https://github.com/jenkins-x/bdd-jx/blob/master/test/_import/jx_import.go#L37&#34; target=&#34;_blank&#34;&gt;test-import-golang-http-from-jenkis-x-yml&lt;/a&gt; in a new cluster using tekton. Check the logs for errors.&lt;/li&gt;
&lt;li&gt;integration - runs all the tests that are inline in jx codebase. Check the logs for errors.&lt;/li&gt;
&lt;li&gt;tide - performs the merge when all the checks pass. Don&amp;rsquo;t worry about the state of this one, it doesn&amp;rsquo;t add much info.
Clicking on the details link is very helpful as it will take you to the dashboard where you can navigate to the &amp;ldquo;Tide&amp;rdquo;
screen and check the status of your PR in the merge queue.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then Jenkins X itself and the maintainers will review your PR, potentially initiate discussion around your change and finally, merge it successfully in Jenkins X jx. Congratulations !&lt;/p&gt;

&lt;h2 id=&#34;getting-a-pull-request-merged&#34;&gt;Getting a pull request merged&lt;/h2&gt;

&lt;p&gt;Now your pull request is submitted, you need to get it merged. If you aren&amp;rsquo;t a regular contributor you&amp;rsquo;ll need a maintainer to manually review your PR and issue a &lt;code&gt;/ok-to-test&lt;/code&gt; command in a PR comment. This will trigger the automated tests. If the tests fail, you&amp;rsquo;ll need to ask one of the maintainers to send you the failure log (in the future we will make these public but first we need to check we are masking all secrets).&lt;/p&gt;

&lt;p&gt;If the tests pass you need to get a &lt;code&gt;/lgtm&lt;/code&gt; from one of the reviewers (listed in the &lt;code&gt;OWNERS&lt;/code&gt; file in the repository). You need a new LGTM every time you push changes. Once the tests pass and you have a LGTM for the latest changeset, your PR will be automatically merged.&lt;/p&gt;

&lt;p&gt;Jenkins X (well, Tide, a component of Jenkins X) won&amp;rsquo;t merge your changes until it has the tests passing against the &lt;em&gt;current&lt;/em&gt; &lt;code&gt;HEAD&lt;/code&gt; of &lt;code&gt;master&lt;/code&gt; - but don&amp;rsquo;t worry, whilst the tests &lt;em&gt;continue&lt;/em&gt; to pass it will automatically merge your changeset into master and rerun the tests. As you can imagine, this can take a little while (a few hours) if the merge queue is long. Tide will also automatically attempt to batch up passing changes, but if the batch fails, it will resort to merging the changesets one by one.&lt;/p&gt;

&lt;p&gt;If the retest against &lt;code&gt;HEAD&lt;/code&gt; of &lt;code&gt;master&lt;/code&gt; fail, then it will notify you on the pull request and you&amp;rsquo;ll need to make some changes (and potentially get a new LGTM).&lt;/p&gt;

&lt;h2 id=&#34;testing&#34;&gt;Testing&lt;/h2&gt;

&lt;p&gt;The jx test suite is divided into three sections:
 - The standard unit test suite
 - Slow unit tests
 - Integration tests&lt;/p&gt;

&lt;p&gt;To run the standard test suite:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run the standard test suite including slow running tests:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ make test-slow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run all tests including integration tests (NOTE These tests are not encapsulated):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ make test-slow-integration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get a nice HTML report on the tests:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ make test-report-html
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;writing-tests&#34;&gt;Writing tests&lt;/h3&gt;

&lt;h4 id=&#34;unit-tests&#34;&gt;Unit Tests&lt;/h4&gt;

&lt;p&gt;Unit tests should be isolated (see below what is an unencapsulated test), and should contain the &lt;code&gt;t.Parallel()&lt;/code&gt; directive in order to keep things nice and speedy.&lt;/p&gt;

&lt;p&gt;If you add a slow running (more than a couple of seconds) test, it needs to be wrapped like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;if testing.Short() {
	t.Skip(&amp;quot;skipping a_long_running_test&amp;quot;)
} else {
	// Slow test goes here...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Slows tests can (and should) still include &lt;code&gt;t.Parallel()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Best practice for unit tests is to define the testing package appending _test to the name of your package, e.g. &lt;code&gt;mypackage_test&lt;/code&gt; and then import &lt;code&gt;mypackage&lt;/code&gt; inside your tests.
This encourages good package design and will enable you to define the exported package API in a composable way.&lt;/p&gt;

&lt;h4 id=&#34;integration-tests&#34;&gt;Integration Tests&lt;/h4&gt;

&lt;p&gt;To add an integration test, create a separate file for your integration tests using the naming convention &lt;code&gt;mypackage_integration_test.go&lt;/code&gt; Use the same package declaration as your unit tests: &lt;code&gt;mypackage_test&lt;/code&gt;. At the very top of the file before the package declaration add this custom build directive:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// +build integration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that there needs to be a blank line before you declare the package name.&lt;/p&gt;

&lt;p&gt;This directive will ensure that integration tests are automatically separated from unit tests, and will not be run as part of the normal test suite.
You should &lt;strong&gt;NOT&lt;/strong&gt; add &lt;code&gt;t.Parallel()&lt;/code&gt; to an unencapsulated test as it may cause intermittent failures.&lt;/p&gt;

&lt;h3 id=&#34;what-is-an-unencapsulated-test&#34;&gt;What is an unencapsulated test?&lt;/h3&gt;

&lt;p&gt;A test is unencapsulated (not isolated) if it cannot be run (with repeatable success) without a certain surrounding state. Relying on external binaries that may not be present, writing or reading from the filesystem without care to specifically avoid collisions, or relying on other tests to run in a specific sequence for your test to pass are all examples of a test that you should carefully consider before committing. If you would like to easily check that your test is isolated before committing simply run: &lt;code&gt;make docker-test&lt;/code&gt;, or if your test is marked as slow: &lt;code&gt;make docker-test-slow&lt;/code&gt;. This will mount the jx project folder into a golang docker container that does not include any of your host machines environment. If your test passes here, then you can be happy that the test is encapsulated.&lt;/p&gt;

&lt;h3 id=&#34;mocking-stubbing&#34;&gt;Mocking / Stubbing&lt;/h3&gt;

&lt;p&gt;&lt;a name=&#34;mocking--stubbing&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mocking or stubbing methods in your unit tests will get you a long way towards test isolation. Coupled with the use of interface based APIs you should be able to make your methods easily testable and useful to other packages that may need to import them.
&lt;a href=&#34;https://github.com/petergtz/pegomock&#34; target=&#34;_blank&#34;&gt;Pegomock&lt;/a&gt; is our current mocking library of choice, mainly because it is very easy to use and doesn&amp;rsquo;t require you to write your own mocks (Yay!)
We place all interfaces for each package in a file called &lt;code&gt;interface.go&lt;/code&gt; in the relevant folder. So you can find all interfaces for &lt;code&gt;github.com/jenkins-x/jx/pkg/util&lt;/code&gt; in &lt;code&gt;github.com/jenkins-x/jx/pkg/util/interface.go&lt;/code&gt;
Generating/regenerating a mock for a given interface is easy, just go to the &lt;code&gt;interface.go&lt;/code&gt; file that corresponds with the interface you would like to mock and add a comment directly above your interface definition that will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// CommandInterface defines the interface for a Command
//go:generate pegomock generate github.com/jenkins-x/jx/pkg/util CommandInterface -o mocks/command_interface.go
type CommandInterface interface {
	DidError() bool
	DidFail() bool
	Error() error
	Run() (string, error)
	RunWithoutRetry() (string, error)
	SetName(string)
	SetDir(string)
	SetArgs([]string)
	SetTimeout(time.Duration)
	SetExponentialBackOff(*backoff.ExponentialBackOff)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example you can see that we pass the generator to use: &lt;code&gt;pegomock generate&lt;/code&gt; the package path name: &lt;code&gt;github.com/jenkins-x/jx/pkg/util&lt;/code&gt; the name of the interface: &lt;code&gt;CommandInterface&lt;/code&gt; and finally an output directive to write the generated file to a mock sub-folder. To keep things nice and tidy it&amp;rsquo;s best to write each mocked interface to a separate file in this folder. So in this case: &lt;code&gt;-o mocks/command_interface.go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now simply run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go generate ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ make generate-mocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You now have a mock to test your new interface!
The new mock can now be imported into your test file and used for easy mocking/stubbing.
Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package util_test

import (
	&amp;quot;errors&amp;quot;
	&amp;quot;testing&amp;quot;

	&amp;quot;github.com/jenkins-x/jx/pkg/util&amp;quot;
	mocks &amp;quot;github.com/jenkins-x/jx/pkg/util/mocks&amp;quot;
	. &amp;quot;github.com/petergtz/pegomock&amp;quot;
	&amp;quot;github.com/stretchr/testify/assert&amp;quot;
)

func TestJXBinaryLocationSuccess(t *testing.T) {
	t.Parallel()
	commandInterface := mocks.NewMockCommandInterface()
	When(commandInterface.RunWithoutRetry()).ThenReturn(&amp;quot;/test/something/bin/jx&amp;quot;, nil)

	res, err := util.JXBinaryLocation(commandInterface)
	assert.Equal(t, &amp;quot;/test/something/bin&amp;quot;, res)
	assert.NoError(t, err, &amp;quot;Should not error&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we&amp;rsquo;re importing the mock we need in our import declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;mocks &amp;quot;github.com/jenkins-x/jx/pkg/util/mocks&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then inside the test we&amp;rsquo;re instantiating &lt;code&gt;NewMockCommandInterface&lt;/code&gt; which was automatically generated for us by pegomock.&lt;/p&gt;

&lt;p&gt;Next we&amp;rsquo;re stubbing something that we don&amp;rsquo;t actually want to run when we execute our test. In this case we don&amp;rsquo;t want to make a call to an external binary as that could break our tests isolation. We&amp;rsquo;re using some handy matchers which are provided by pegomock, and importing using a &lt;code&gt;.&lt;/code&gt; import to keep the syntax neat (You probably shouldn&amp;rsquo;t do this outside of tests):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;When(commandInterface.RunWithoutRetry()).ThenReturn(&amp;quot;/test/something/bin/jx&amp;quot;, nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when we can set up our  test using the mock interface and make assertions as normal.&lt;/p&gt;

&lt;h3 id=&#34;debug-logging&#34;&gt;Debug logging&lt;/h3&gt;

&lt;p&gt;Lots of the test have debug output to try figure out when things fail. You can enable verbose debug logging for tests via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JX_TEST_DEBUG=true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;debugging&#34;&gt;Debugging&lt;/h2&gt;

&lt;p&gt;First you need to &lt;a href=&#34;https://github.com/derekparker/delve/blob/master/Documentation/installation/README.md&#34; target=&#34;_blank&#34;&gt;install Delve&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Then build a version of &lt;code&gt;jx&lt;/code&gt; that is optimised for debugging&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;DEBUG=on make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you should be able to run a debug version of a jx command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dlv --listen=:2345 --headless=true --api-version=2 exec ./build/jx -- some arguments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in your IDE you should be able to set a breakpoint and connect to &lt;code&gt;2345&lt;/code&gt; e.g. in IntelliJ you create a new &lt;code&gt;Go Remote&lt;/code&gt; execution and then hit &lt;code&gt;Debug&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;debugging-jx-with-stdin&#34;&gt;Debugging jx with stdin&lt;/h3&gt;

&lt;p&gt;If you want to debug using &lt;code&gt;jx&lt;/code&gt; with &lt;code&gt;stdin&lt;/code&gt; to test out terminal interaction, you can start &lt;code&gt;jx&lt;/code&gt; as usual from the command line then:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find the &lt;code&gt;pid&lt;/code&gt; of the jx command via something like &lt;code&gt;ps -elaf | grep jx&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Start Delve, attaching to the pid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dlv --listen=:2345 --headless=true --api-version=2 attach SomePID
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;debugging-a-unit-test&#34;&gt;Debugging a unit test&lt;/h3&gt;

&lt;p&gt;You can run a single unit test via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export TEST=&amp;quot;TestSomething&amp;quot;
make test1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can then start a Delve debug session on a unit test via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export TEST=&amp;quot;TestSomething&amp;quot;
make debugtest1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then set breakpoints and debug in your IDE as described in &lt;a href=&#34;#debugging&#34;&gt;Debugging&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;using-a-helper-script&#34;&gt;Using a helper script&lt;/h3&gt;

&lt;p&gt;If you create a bash file called &lt;code&gt;jxDebug&lt;/code&gt; as the following (replacing &lt;code&gt;SomePid&lt;/code&gt; with the actual &lt;code&gt;pid&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
echo &amp;quot;Debugging jx&amp;quot;
dlv --listen=:2345 --headless=true --api-version=2 exec `which jx` -- $*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can change your &lt;code&gt;jx someArgs&lt;/code&gt; CLI to &lt;code&gt;jxDebug someArgs&lt;/code&gt; then debug it!&lt;/p&gt;

&lt;h3 id=&#34;enabling-kubernetes-api-tracing&#34;&gt;Enabling Kubernetes API tracing&lt;/h3&gt;

&lt;p&gt;In some cases it can be useful to see the REST API calls made to the Kubernetes cluster.
You can enable trace by setting the environment variable &lt;code&gt;TRACE_KUBE_API&lt;/code&gt; to the value &amp;ldquo;on&amp;rdquo; or &amp;ldquo;1&amp;rdquo;.
For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;TRACE_KUBE_API=on jx get apps
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;try-a-new-version-of-jx-inside-a-pipeline&#34;&gt;Try a new version of jx inside a pipeline&lt;/h2&gt;

&lt;p&gt;You can usually just run &lt;code&gt;jx&lt;/code&gt; locally on your laptop and can simulate being in a pipeline using environment variables and run it inside a git clone of a sample project etc. However there are times you really want to test inside an actual running pipeline - here&amp;rsquo;s how:&lt;/p&gt;

&lt;p&gt;When you create a Pull Request and its approved for test we generate preview docker images you can use inside your jenkins server pipelines for maven/go/nodejs builders.&lt;/p&gt;

&lt;p&gt;e.g. see the &lt;code&gt;SNAPSHOT-JX_PR-$ID-$BUILD_NUMBER&lt;/code&gt; images for the &lt;a href=&#34;https://hub.docker.com/r/jenkinsxio/builder-maven/tags/&#34; target=&#34;_blank&#34;&gt;jenkinsxio/builder-maven&lt;/a&gt; image&lt;/p&gt;

&lt;p&gt;Once you have a preview docker image you can then edit the jenkins pod template for maven/go/nodejs to use your PR’s docker image to try out your changes to jx in a jenkins pipeline. To do this&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jx console&lt;/code&gt; to open the Jenkins console&lt;/li&gt;
&lt;li&gt;Manage Jenkins -&amp;gt; Configure System&lt;/li&gt;
&lt;li&gt;search for builder-(maven|go|nodejs) and use the new docker image version you just built (that ends in your &lt;code&gt;PR number-buildnumber&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;now retrigger a pipeline&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We don&amp;rsquo;t yet do the same for serverless jenkins images am afraid - for that you&amp;rsquo;ll have to make your own Docker image replacing the &lt;code&gt;jx&lt;/code&gt; binary then edit the Prow configuration (&lt;code&gt;kubectl edit cm config&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Another approach is you can make your own docker image, then pause a pipeline and &lt;code&gt;kubectl cp&lt;/code&gt; your linux build of &lt;code&gt;jx&lt;/code&gt; into the docker image and &lt;code&gt;kubectl exec&lt;/code&gt; or &lt;code&gt;jx rsh&lt;/code&gt; into the build pod and run the &lt;code&gt;jx&lt;/code&gt; command there.&lt;/p&gt;

&lt;h2 id=&#34;code-generation&#34;&gt;Code Generation&lt;/h2&gt;

&lt;p&gt;Jenkins X makes use of code generation to create &lt;a href=&#34;#mocking--stubbing&#34;&gt;Mocks&lt;/a&gt;, Kubernetes Custom Resource clients, &lt;a href=&#34;../apidocs&#34;&gt;OpenAPI spec and API Documentation&lt;/a&gt;.
The generated files, except for the HTML docs, checked into version control.
There are several &lt;code&gt;make&lt;/code&gt; targets resposible for code generation.
They can be found in &lt;code&gt;Makefile.codegen&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make generate&lt;/code&gt; runs all generation you need to do before commiting changes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make generate-mocks&lt;/code&gt; - generates the &lt;a href=&#34;https://github.com/petergtz/pegomock&#34; target=&#34;_blank&#34;&gt;Pegomocks&lt;/a&gt; only&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make generate-client&lt;/code&gt; - generates the Kubernetes Custom Resource clientset only.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make generate-openapi&lt;/code&gt; generates the &lt;a href=&#34;https://swagger.io/specification/&#34; target=&#34;_blank&#34;&gt;OpenAPI&lt;/a&gt; spec only&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make generate-docs&lt;/code&gt; generates the HTML apidocs, and is not committed&lt;/li&gt;
&lt;/ul&gt;



&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;

Not all files under &lt;code&gt;pkg/client/clientset/versioned/typed/jenkins.io/v1&lt;/code&gt; are generated.
 The expansion files are manually maintained and need to be kept when re-generating the clientset.
 See also &lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machingenerating-clientset.md&#34; target=&#34;_blank&#34;&gt;clientset generation&lt;/a&gt; in the Kuberenetes Community repository.
&lt;/div&gt;


&lt;p&gt;If you get a conflict on any of these directories or files when committing, rebasing or merging your best bet is to discard the changeset you have, and regenerate:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pkg/client&lt;/code&gt; (&lt;code&gt;make generate-client&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/apidocs/openapi-spec&lt;/code&gt; (&lt;code&gt;make generate-openapi&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**/mocks/**&lt;/code&gt; (&lt;code&gt;make generate-mocks&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As part of the PR builds we run a job to validate that the code generation is up to date.
If the code generation is not up to date (running &lt;code&gt;make generate&lt;/code&gt; produces a &lt;code&gt;git diff&lt;/code&gt; or untracked files) then your PR will be blocked.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Contribute to the Documentation</title>
      <link>/docs/contributing/documentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/contributing/documentation/</guid>
      <description>
        
        
        

&lt;p&gt;Contributing to the documentation is easy, and a great way to get involved. Plus, you don&amp;rsquo;t have to contribute code to be able to contribute to the documentation.&lt;/p&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;The first thing you&amp;rsquo;ll need to do, is get your local environment setup so that you can add/change content and make sure it looks right, before raising a Pull Request.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll go through each step below, but here&amp;rsquo;s what you need to get started:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Install Docker&lt;/li&gt;
&lt;li&gt;Fork the &lt;code&gt;jx/jx-docs&lt;/code&gt; repo&lt;/li&gt;
&lt;li&gt;Build a Hugo docker image to preview changes&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;install-docker&#34;&gt;Install Docker&lt;/h3&gt;

&lt;p&gt;How to install a Docker engine depends on your platform etc., so best to head over to &lt;a href=&#34;https://docs.docker.com/install/&#34; target=&#34;_blank&#34;&gt;Docker&lt;/a&gt; to find the right one.&lt;/p&gt;

&lt;h3 id=&#34;fork-the-repo&#34;&gt;Fork the repo&lt;/h3&gt;

&lt;p&gt;To fork the &lt;code&gt;jx-docs&lt;/code&gt; repo, simply go to &lt;a href=&#34;https://github.com/jenkins-x/jx-docs&#34; target=&#34;_blank&#34;&gt;https://github.com/jenkins-x/jx-docs&lt;/a&gt; and click the &amp;ldquo;Fork&amp;rdquo; button in the top right-hand corner.
Make sure you&amp;rsquo;re logged in to Github first.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll also need to create a git reference to the main &lt;code&gt;jx-docs&lt;/code&gt; repo for when you&amp;rsquo;re creating new branches:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git remote add upstream https://github.com/jenkins-x/jx-docs.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to know more about forking repos, see &lt;a href=&#34;https://help.github.com/articles/fork-a-repo/&#34; target=&#34;_blank&#34;&gt;GitHub&amp;rsquo;s documentation on &amp;ldquo;forking&amp;rdquo;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;typical-workflow&#34;&gt;Typical Workflow&lt;/h2&gt;

&lt;p&gt;Once you&amp;rsquo;ve completed the initial steps to get started, you can begin to make changes and add new content.&lt;/p&gt;

&lt;p&gt;At a high level, your workflow will likely look something like this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a new branch for you work&lt;/li&gt;
&lt;li&gt;Start the Hugo server to preview your changes (updates the site live)&lt;/li&gt;
&lt;li&gt;Make changes/add new content&lt;/li&gt;
&lt;li&gt;Commit and push your changes to your fork of &lt;code&gt;jx-docs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Raise a Pull Request (PR) to have your changes merged into the main &lt;code&gt;jx-docs&lt;/code&gt; repo&lt;/li&gt;
&lt;li&gt;Wait for and then participate in a review of your changes

&lt;ul&gt;
&lt;li&gt;might involve making adjustments or adding a bit more&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;See your changes go live on the &lt;a href=&#34;https://jenkins-x.io&#34; target=&#34;_blank&#34;&gt;Jenkins X site&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll go though each of the steps below in more detail&lt;/p&gt;

&lt;h3 id=&#34;create-a-new-branch&#34;&gt;Create a new branch&lt;/h3&gt;

&lt;p&gt;You should generally create a branch for each &amp;ldquo;chunk of work&amp;rdquo; that you take on. If you wanted to update two completely different parts of the site, you should create two separate branches instead of one (unless it&amp;rsquo;s the same change across a bunch of files&amp;hellip;there are always exceptions to the rule).&lt;/p&gt;

&lt;p&gt;The reason for the separate branches is to make it easier to get each change merged into the main repo. If one of your changes required no changes, but your second change required a lot of changes, having two branches instead of one would allow your first change to be merged separately from your second.&lt;/p&gt;

&lt;p&gt;Naming is also important when creating branches (&amp;ldquo;blabla 24&amp;rdquo; is not as meaningful as &amp;ldquo;minor grammatical fixes&amp;rdquo;) and so is the process of creating a branch. You&amp;rsquo;d want to start off on at the right spot, so that your changes don&amp;rsquo;t get mixed up. Here&amp;rsquo;s how to do that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch upstream
$ git checkout master
$ git merge upstream/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This ensures that you&amp;rsquo;re starting from where ever the live website is, so you avoid including other commits you might have added since the last update of the site.&lt;/p&gt;

&lt;p&gt;Now create your branch with a meaningful name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git checkout -b &amp;lt;BRANCH-NAME&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;start-the-hugo-server&#34;&gt;Start the Hugo server&lt;/h3&gt;

&lt;p&gt;The documentation (and the rest of the website) is generated using the static site generator &lt;a href=&#34;https://gohugo.io&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt;, and you&amp;rsquo;ll need a copy of that locally to be able to preview the site.&lt;/p&gt;

&lt;p&gt;To make this as easy as possible, we&amp;rsquo;ve created a Dockerfile and a docker-compose.yml file that you can use spin up a preview server without having to install a bunch of other software.&lt;/p&gt;

&lt;p&gt;First make sure you&amp;rsquo;re in the folder with the cloned repo (if you haven&amp;rsquo;t done anything in your terminal since cloning the repo, just run &lt;code&gt;cd jx-docs&lt;/code&gt;), then run the following command to build and start the Hugo server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose up -d server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will make the site available on &lt;a href=&#34;http://localhost:1313/&#34; target=&#34;_blank&#34;&gt;http://localhost:1313/&lt;/a&gt; and it will auto-update when you save changes to any of the files in the repo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: if you want to stop the server or if it stops auto-rebuilding and you want to restart it, simply run &lt;code&gt;docker-compose down server&lt;/code&gt; and wait for it to finish. This will shut down the server and kill the container as well.&lt;/p&gt;

&lt;h3 id=&#34;make-changes&#34;&gt;Make Changes&lt;/h3&gt;

&lt;p&gt;All pages are written in GitHub-flavored markdown (see &lt;a href=&#34;#syntax-reference&#34;&gt;below&lt;/a&gt; for details on syntax).&lt;/p&gt;

&lt;p&gt;Some things, like the footer etc. are in the &lt;code&gt;/themes/gohugoioTheme&lt;/code&gt; structure, but most likely you&amp;rsquo;ll just be adding/changing things in the various page structures.&lt;/p&gt;

&lt;h3 id=&#34;add-new-content&#34;&gt;Add new Content&lt;/h3&gt;

&lt;p&gt;The Jenkins X docs make heavy use of Jenkins X&amp;rsquo;s &lt;a href=&#34;/content-management/archetypes/&#34;&gt;archetypes&lt;/a&gt; feature. All content sections in Jenkins X documentation have an assigned archetype.&lt;/p&gt;

&lt;p&gt;Adding new content to the Jenkins X docs follows the same pattern, regardless of the content section:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-compose run server new &amp;lt;DOCS-SECTION&amp;gt;/&amp;lt;new-content-lowercase&amp;gt;.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;commit-and-push-your-changes&#34;&gt;Commit and push your changes&lt;/h3&gt;

&lt;p&gt;When you&amp;rsquo;ve finished, and verified that everything looks good (using the Hugo server), you should run one last check to verify that you didn&amp;rsquo;t break anything.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Checking References and Links&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re using a tool called &lt;a href=&#34;https://github.com/wjdp/htmltest&#34; target=&#34;_blank&#34;&gt;htmltest&lt;/a&gt; to check that links are still valid etc. so you just need to run the following commands to build the site locally, and verify that everything looks good:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose run server hugo
$ docker-compose up linkchecker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Checking Spelling&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For spell checking, we&amp;rsquo;re using &lt;a href=&#34;https://github.com/lukeapage/node-markdown-spellcheck&#34; target=&#34;_blank&#34;&gt;node-markdown-spellcheck&lt;/a&gt; to run through all our markdown files and list any spelling issue or unknown word it can find.&lt;/p&gt;

&lt;p&gt;To make this as simple as possible, just run the following command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose up spellchecker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will output any issue the spell checker have found.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s likely that the report includes words that are spelled correctly, but that just means the spell checker is not aware of the correct spelling (happens a lot for technical terms, commands, etc.). Please edit the &lt;code&gt;.spelling&lt;/code&gt; file and add the unknown word.
Also, please try and keep the list alphabetically sorted; makes it easier to navigate when you&amp;rsquo;re looking for something&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Commit &amp;amp; Push&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If everything is good, you can commit your changes, and push them to your fork:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git push --set-upstream origin &amp;lt;BRANCH-NAME&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need to push more commits to the same branch, you can just use &lt;code&gt;git push&lt;/code&gt; going forward; set-upstream is only needed once.&lt;/p&gt;

&lt;h3 id=&#34;raise-a-pull-request&#34;&gt;Raise a Pull Request&lt;/h3&gt;

&lt;p&gt;Github is generally very helpful in letting you raise a pull request from your fork to the main &lt;code&gt;jx-docs&lt;/code&gt; repo. You&amp;rsquo;ll need to add a few labels etc. though, so make sure your PR is seen and reviewed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;assign the PR to yourself&lt;/li&gt;
&lt;li&gt;add the PR to the &lt;code&gt;Jenkins X Documentation&lt;/code&gt; project&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can leave the rest blank; reviewers and labels will be added automatically.&lt;/p&gt;

&lt;h3 id=&#34;review-process&#34;&gt;Review Process&lt;/h3&gt;

&lt;p&gt;The final part of all of this, is letting others review your work and provide feedback. As a rule of thumb, the conversation should happen on the PR, but sometimes things will be sorted out via Slack or a video call.&lt;/p&gt;

&lt;p&gt;Sometimes it may take a few days for a review to happen (depends on how many are monitoring the [Jenkins X Documentation]() project). If you feel it&amp;rsquo;s an urgent change, jump on the community slack channel &lt;code&gt;#jenkins-x-user&lt;/code&gt; and ask for someone to review your PR.&lt;/p&gt;

&lt;p&gt;Once the review is done, your changes will be merged into the master branch, and the site will be updated.&lt;/p&gt;

&lt;h2 id=&#34;working-with-the-local-hugo-server&#34;&gt;Working With The Local Hugo Server&lt;/h2&gt;

&lt;p&gt;As you&amp;rsquo;re changing things and adding new content, your local Hugo server might get a bit wonky at times or you&amp;rsquo;ll want to see what errors it&amp;rsquo;s throwing. Here&amp;rsquo;s a few simple commands to work with your local Hugo:&lt;/p&gt;

&lt;h3 id=&#34;see-the-hugo-logs&#34;&gt;See the Hugo Logs&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;$ docker-compose logs -f server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Leave &lt;code&gt;-f&lt;/code&gt; off if you don&amp;rsquo;t want new log entries to show up in your console. (ctrl-c to escape when &lt;code&gt;-f&lt;/code&gt; is on)&lt;/p&gt;

&lt;h3 id=&#34;restart-the-hugo-server&#34;&gt;Restart the Hugo Server&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;$ docker-compose restart server
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stop-the-hugo-server&#34;&gt;Stop the Hugo Server&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;$ docker-compose stop server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;$ docker-compose down
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to shut down everything started by docker-compose&lt;/p&gt;

&lt;h2 id=&#34;syntax-reference&#34;&gt;Syntax Reference&lt;/h2&gt;

&lt;h3 id=&#34;standard-syntax&#34;&gt;Standard Syntax&lt;/h3&gt;

&lt;p&gt;Across all pages on the Jenkins X docs, the typical triple-back-tick markdown syntax is used. If you do not want to take the extra time to implement the following code block shortcodes, please use standard GitHub-flavored markdown. The Jenkins X docs use a version of &lt;a href=&#34;https://highlightjs.org/&#34; target=&#34;_blank&#34;&gt;highlight.js&lt;/a&gt; with a specific set of languages.&lt;/p&gt;

&lt;p&gt;Your options for languages are &lt;code&gt;xml&lt;/code&gt;/&lt;code&gt;html&lt;/code&gt;, &lt;code&gt;go&lt;/code&gt;/&lt;code&gt;golang&lt;/code&gt;, &lt;code&gt;md&lt;/code&gt;/&lt;code&gt;markdown&lt;/code&gt;/&lt;code&gt;mkd&lt;/code&gt;, &lt;code&gt;handlebars&lt;/code&gt;, &lt;code&gt;apache&lt;/code&gt;, &lt;code&gt;toml&lt;/code&gt;, &lt;code&gt;yaml&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;css&lt;/code&gt;, &lt;code&gt;asciidoc&lt;/code&gt;, &lt;code&gt;ruby&lt;/code&gt;, &lt;code&gt;powershell&lt;/code&gt;/&lt;code&gt;ps&lt;/code&gt;, &lt;code&gt;scss&lt;/code&gt;, &lt;code&gt;sh&lt;/code&gt;/&lt;code&gt;zsh&lt;/code&gt;/&lt;code&gt;bash&lt;/code&gt;/&lt;code&gt;git&lt;/code&gt;, &lt;code&gt;http&lt;/code&gt;/&lt;code&gt;https&lt;/code&gt;, and &lt;code&gt;javascript&lt;/code&gt;/&lt;code&gt;js&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-md&#34;&gt;```go
// CommandInterface defines the interface for a Command
//go:generate pegomock generate github.com/jenkins-x/jx/pkg/util CommandInterface -o mocks/command_interface.go
type CommandInterface interface {
	DidError() bool
	DidFail() bool
	Error() error
	Run() (string, error)
	RunWithoutRetry() (string, error)
	SetName(string)
	SetDir(string)
	SetArgs(\[]string)
	SetTimeout(time.Duration)
	SetExponentialBackOff(\*backoff.ExponentialBackOff)
}
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;becomes&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CommandInterface defines the interface for a Command
//go:generate pegomock generate github.com/jenkins-x/jx/pkg/util CommandInterface -o mocks/command_interface.go
type CommandInterface interface {
	DidError() bool
	DidFail() bool
	Error() error
	Run() (string, error)
	RunWithoutRetry() (string, error)
	SetName(string)
	SetDir(string)
	SetArgs(\[]string)
	SetTimeout(time.Duration)
	SetExponentialBackOff(\*backoff.ExponentialBackOff)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;blockquotes&#34;&gt;Blockquotes&lt;/h2&gt;

&lt;p&gt;Blockquotes can be added to the Jenkins X documentation using &lt;a href=&#34;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#blockquotes&#34; target=&#34;_blank&#34;&gt;typical Markdown blockquote syntax&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Without the threat of punishment, there is no joy in flight.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The preceding blockquote will render as follows in the Jenkins X docs:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Without the threat of punishment, there is no joy in flight.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;However, you can add a quick and easy &lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt; element (added on the client via JavaScript) by separating your main blockquote and the citation with a hyphen with a single space on each side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Without the threat of punishment, there is no joy in flight. - [Kobo Abe](https://en.wikipedia.org/wiki/Kobo_Abe)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which will render as follows in the Jenkins X docs:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Without the threat of punishment, there is no joy in flight. - &lt;a href=&#34;https://en.wikipedia.org/wiki/Kobo_Abe&#34; target=&#34;_blank&#34;&gt;Kobo Abe&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Overview</title>
      <link>/docs/contributing/addons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/contributing/addons/</guid>
      <description>
        
        
        

&lt;blockquote&gt;
&lt;p&gt;This guide is still a work in progress!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In this guide we will explore the Apps Framework that allows you to extend and enhance the capabilities in Jenkins X.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We&amp;rsquo;re still working on the ability to alter the pipeline from an app - right now our apps include a section in the
  README explaining how to change your &lt;code&gt;JenkinsFile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once complete an App will be able to add, remove and alter stages of the pipeline.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jenkins X is built on top of Kubernetes. Kubernetes is highly configurable and extensible. This extensibility forms the
basis of many of the ways we recommend extending Jenkins X.&lt;/p&gt;

&lt;p&gt;The Apps Framework consists of a number of areas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the install and configuration framework&lt;/li&gt;
&lt;li&gt;the APIs offered by Jenkins&lt;/li&gt;
&lt;li&gt;the data model&lt;/li&gt;
&lt;li&gt;pipeline extensibility&lt;/li&gt;
&lt;li&gt;the testing framework&lt;/li&gt;
&lt;li&gt;plugins for the &lt;code&gt;jx&lt;/code&gt; CLI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this reference guide we&amp;rsquo;ll cover each of these areas in depth. We also provide a number of other resources for
working with the Apps Framework:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tutorials&lt;/li&gt;
&lt;li&gt;How To&amp;rsquo;s&lt;/li&gt;
&lt;li&gt;Articles&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;install-and-configuration-framework&#34;&gt;Install and Configuration Framework&lt;/h1&gt;

&lt;p&gt;Jenkins X Apps are distributed as Helm Charts via Helm Chart repositories. Any Helm chart can be installed as an app
using &lt;code&gt;jx add app&lt;/code&gt;, although Jenkins X adds various capabilities to Helm Charts including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the ability to interactively ask questions to generate &lt;code&gt;values.yaml&lt;/code&gt; based on JSON Schema&lt;/li&gt;
&lt;li&gt;the ability to create pull requests against the GitOps repo that manages your team/cluster&lt;/li&gt;
&lt;li&gt;the ability to store secrets in vault&lt;/li&gt;
&lt;li&gt;the ability to upgrade all apps to the latest version&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Planned features include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;integrating &lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize&#34; target=&#34;_blank&#34;&gt;kustomize&lt;/a&gt; to allow existing charts to be modified&lt;/li&gt;
&lt;li&gt;storing Helm repository credentials in vault&lt;/li&gt;
&lt;li&gt;taking existing &lt;code&gt;values.yaml&lt;/code&gt; as defaults when asking questions based on JSON Schema during app upgrade&lt;/li&gt;
&lt;li&gt;only asking new questions during app upgrade&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jx get apps&lt;/code&gt; - the ability to list all apps that can be installed&lt;/li&gt;
&lt;li&gt;integration for bash completion&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;apis&#34;&gt;APIs&lt;/h1&gt;

&lt;p&gt;APIs can be consumed from a microservice deployed to Kubernetes, from outside the cluster (with appropriate
configuration for authentication) or from inside pipeline extensions.&lt;/p&gt;

&lt;p&gt;Jenkins X APIs uses &lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34;&gt;Kubernetes Custom Resources&lt;/a&gt; to expose its API. The API is declarative, and
Jenkins X uses controllers to try to match the actual state to the desired state. Jenkins X continually takes action
to achieve and maintain the desired state.&lt;/p&gt;

&lt;p&gt;Jenkins X uses this architectural pattern itself meaning that this API is very complete.&lt;/p&gt;

&lt;p&gt;Custom resources are exposed by the Kubernetes API server and can be accessed as REST endpoints, using &lt;code&gt;kubectl&lt;/code&gt; or
via client libraries for different platforms. Currently we offer clients for:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Java (incomplete) - &lt;a href=&#34;https://github.com/jenkins-x-quickstarts/spring-boot-watch-pipeline-activity&#34; target=&#34;_blank&#34;&gt;Quickstart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Javascript &lt;a href=&#34;https://github.com/jenkins-x-quickstarts/spring-boot-watch-pipeline-activity&#34; target=&#34;_blank&#34;&gt;Quickstart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;using-jx-as-a-library&#34;&gt;Using &lt;code&gt;jx&lt;/code&gt; as a library&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jenkins-x/jx&#34; target=&#34;_blank&#34;&gt;jx&lt;/a&gt; contains many useful functions and is documented on &lt;a href=&#34;https://godoc.org/github.com/jenkins-x/jx&#34; target=&#34;_blank&#34;&gt;godoc.org&lt;/a&gt;. The easiest way to consume it is is as a go module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go get github.com/jenkins-x/jx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jx-app-cli-commands&#34;&gt;&lt;code&gt;jx&lt;/code&gt; app CLI Commands&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/commands/jx_add_app/&#34;&gt;jx add app&lt;/a&gt;    - Adds an app to Jenkins X&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/commands/jx_delete_app/&#34;&gt;jx delete app&lt;/a&gt;  - Deletes one or more apps from Jenkins X&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/commands/jx_get_apps/&#34;&gt;jx get apps&lt;/a&gt;  - Display one or more installed apps&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/commands/jx_upgrade_apps/&#34;&gt;jx upgrade apps&lt;/a&gt;  - Upgrades one or more apps to a newer release&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;source-code-management&#34;&gt;Source code management&lt;/h2&gt;

&lt;p&gt;The ability to add new SCM connections to Jenkins X from an app is under active development.&lt;/p&gt;

&lt;h2 id=&#34;identity-management&#34;&gt;Identity Management&lt;/h2&gt;

&lt;p&gt;In the future we intend to add the ability to plug your own identity management and SSO solution in to Jenkins X.&lt;/p&gt;

&lt;h2 id=&#34;custom-quickstarts&#34;&gt;Custom Quickstarts&lt;/h2&gt;

&lt;p&gt;Jenkins X ships with a series of quickstarts that provide you with pre-made applications that you can start a project with.&lt;/p&gt;

&lt;p&gt;You can create your own quickstarts that give your team members a starting point. Read more about &lt;a href=&#34;/developing/create-quickstart&#34;&gt;creating quickstarts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can customize the list of quickstarts available to your team making it easier for them to select the right place to start. Read more about &lt;a href=&#34;/developing/create-quickstart#customising-your-teams-quickstarts&#34;&gt;customizing the quickstarts available&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;pipeline-extensibility&#34;&gt;Pipeline Extensibility&lt;/h1&gt;

&lt;h2 id=&#34;pipeline-triggers&#34;&gt;Pipeline triggers&lt;/h2&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&#34;build-environment-creds-env-vars-parameters&#34;&gt;Build environment (creds, env vars, parameters)&lt;/h2&gt;

&lt;h3 id=&#34;build-packs-pod-templates&#34;&gt;Build Packs &amp;amp; Pod Templates&lt;/h3&gt;

&lt;p&gt;In Jenkins X a &lt;em&gt;Build Pack&lt;/em&gt; allows you to transform source code into a applications which can be deployed on Kubernetes. Build Packs are based on &lt;a href=&#34;https://draft.sh/&#34; target=&#34;_blank&#34;&gt;draft&lt;/a&gt;, and will automatically add:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Dockerfile&lt;/code&gt; to turn the code into an immutable docker image for running on kubernetes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Jenkinsfile&lt;/code&gt; to define the declarative Jenkins pipeline to define the CI/CD steps for the application&lt;/li&gt;
&lt;li&gt;helm chart in the &lt;code&gt;charts&lt;/code&gt; folder to generate the kubernetes resources to run the application on kubernetes&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;preview chart&lt;/em&gt; in the &lt;code&gt;charts/preview&lt;/code&gt; folder to define any dependencies for deploying a preview environment on a Pull Request&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you need to add support for different languages or build tools then you will need to create a new &lt;em&gt;Pod Template&lt;/em&gt;. A pod template defines the pod used to run the build, and consists of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;one or more build containers for running commands inside (e.g. your build tools like &lt;code&gt;mvn&lt;/code&gt; or &lt;code&gt;npm&lt;/code&gt; along with tools we use for other parts of the pipeline like &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;jx&lt;/code&gt;, &lt;code&gt;helm&lt;/code&gt;, &lt;code&gt;kubectl&lt;/code&gt; etc)&lt;/li&gt;
&lt;li&gt;volumes for persistence&lt;/li&gt;
&lt;li&gt;environment variables&lt;/li&gt;
&lt;li&gt;secrets so the pipeline can write to git repositories, docker registries, maven/npm/helm repositories and so forth&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read more about &lt;a href=&#34;/architecture/build-packs#creating-new-build-packs&#34;&gt;creating build packs&lt;/a&gt; and &lt;a href=&#34;/architecture/pod-templates&#34;&gt;creating pod templates&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;build-stages&#34;&gt;Build Stages&lt;/h2&gt;

&lt;p&gt;Build stages are defined in the &lt;code&gt;Jenkinsfile&lt;/code&gt;. The &lt;code&gt;Jenkinsfile&lt;/code&gt; defines the actions to take, and the order in which to
take the actions.&lt;/p&gt;

&lt;p&gt;The order is of actions is procedural - the first action defined will be executed first. Simple conditions are supported via the &lt;code&gt;when&lt;/code&gt; directive.&lt;/p&gt;

&lt;p&gt;The action that can be taken are defined by the pipeline engine. In the case of a Jenkinsfile these are defined in the &lt;a href=&#34;https://jenkins.io/doc/pipeline/steps/&#34; target=&#34;_blank&#34;&gt;Pipeline Steps Reference&lt;/a&gt;. Typically in Jenkins X we use the &lt;code&gt;sh&lt;/code&gt; step which allows us to execute any shell script in the build container.&lt;/p&gt;

&lt;p&gt;Read more about &lt;a href=&#34;https://jenkins.io/doc/book/pipeline/syntax/&#34; target=&#34;_blank&#34;&gt;defining pipelines&lt;/a&gt; using the &lt;code&gt;Jenkinsfile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re still working on adding the ability to customize build stages to the Apps Framework.&lt;/p&gt;

&lt;h1 id=&#34;data-model&#34;&gt;Data Model&lt;/h1&gt;

&lt;h1 id=&#34;testing-frame&#34;&gt;Testing Frame&lt;/h1&gt;

&lt;h1 id=&#34;jx-cli-plugins&#34;&gt;&lt;code&gt;jx&lt;/code&gt; CLI plugins&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;jx&lt;/code&gt; CLI can be extended with binary plugins. Binary plugins are separate binaries to &lt;code&gt;jx&lt;/code&gt; that are entirely
responsible for their own execution (argument parsing, subcommands, platform compatibility). We strongly recommend
writing binary plugins in Go and using the &lt;a href=&#34;https://github.com/spf13/cobra&#34; target=&#34;_blank&#34;&gt;Cobra CLI framework&lt;/a&gt; just like &lt;code&gt;jx&lt;/code&gt;
itself. Binary plugins can import &lt;code&gt;jx&lt;/code&gt; as a library of useful functions.&lt;/p&gt;

&lt;p&gt;Jenkins X provides a management framework for binary plugins that allows them to be automatically installed on the
users machine when the relevant subcommand is called. The management framework will also take care of upgrading and
removing plugins as needed. Plugins are managed by adding a custom resource to the team or cluster.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
