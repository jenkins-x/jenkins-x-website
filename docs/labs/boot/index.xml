<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins X – Boot</title>
    <link>/docs/labs/boot/</link>
    <description>Recent content in Boot on Jenkins X</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="/docs/labs/boot/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Getting Started</title>
      <link>/docs/labs/boot/getting-started/</link>
      <pubDate>Wed, 01 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/getting-started/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: Multi-Cluster</title>
      <link>/docs/labs/boot/multi-cluster/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/multi-cluster/</guid>
      <description>
        
        
        &lt;p&gt;We recommend using separate clusters for your &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; environments. This lets you completely isolate your environments which improves security.&lt;/p&gt;
&lt;h2 id=&#34;setting-up-multi-cluster&#34;&gt;Setting up multi cluster&lt;/h2&gt;
&lt;p&gt;To enable multi cluster you need to specify &lt;code&gt;remoteCluster: true&lt;/code&gt; on your &lt;code&gt;Staging&lt;/code&gt; and/or &lt;code&gt;Production&lt;/code&gt; environments in your &lt;code&gt;jx-requirements.yml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The easiest way to do that is passing in &lt;code&gt;--env-remote&lt;/code&gt;  when you &lt;a href=&#34;/docs/labs/boot/getting-started/repository/&#34;&gt;created your environment git repositories&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jxl boot create --env-remote
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or if you&amp;rsquo;ve already &lt;a href=&#34;/docs/labs/boot/getting-started/repository/&#34;&gt;created your environment git repositories&lt;/a&gt; you can modify your &lt;code&gt;jx-requirements.yml&lt;/code&gt; to something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bootConfigURL&lt;/span&gt;: https://github.com/jenkins-x/jenkins-x-boot-helmfile-config
&lt;span style=&#34;color:#66d9ef&#34;&gt;cluster&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;gitKind&lt;/span&gt;: github
  &lt;span style=&#34;color:#66d9ef&#34;&gt;gitName&lt;/span&gt;: github
  &lt;span style=&#34;color:#66d9ef&#34;&gt;gitServer&lt;/span&gt;: https://github.com
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: jx
&lt;span style=&#34;color:#66d9ef&#34;&gt;environments&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt;: dev
- &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt;: staging
  &lt;span style=&#34;color:#66d9ef&#34;&gt;remoteCluster&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
- &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt;: production
  &lt;span style=&#34;color:#66d9ef&#34;&gt;remoteCluster&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;gitops&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;helmfile&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;kaniko&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: nexus
&lt;span style=&#34;color:#66d9ef&#34;&gt;secretStorage&lt;/span&gt;: local
&lt;span style=&#34;color:#66d9ef&#34;&gt;versionStream&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;ref&lt;/span&gt;: v1&lt;span style=&#34;color:#ae81ff&#34;&gt;.0.330&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;url&lt;/span&gt;: https://github.com/jenkins-x/jenkins-x-versions.git
&lt;span style=&#34;color:#66d9ef&#34;&gt;webhook&lt;/span&gt;: lighthouse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;setup-the-development-cluster-as-normal&#34;&gt;Setup the development cluster as normal&lt;/h3&gt;
&lt;p&gt;Follow the &lt;a href=&#34;/docs/labs/boot/getting-started/&#34;&gt;getting started guide for helm 3 boot&lt;/a&gt; to setup the secrets and boot up the development cluster.&lt;/p&gt;
&lt;h3 id=&#34;configure-the-stagingproduction-git-repository&#34;&gt;Configure the Staging/Production git repository&lt;/h3&gt;
&lt;p&gt;First make sure you do:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;export NAMESPACE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;jx-staging
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you will need to follow the instructions to &lt;a href=&#34;/docs/labs/boot/getting-started/cloud/&#34;&gt;setup the cloud resources for the Staging/Production cluster&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When you are connected to the Staging/Production cluster you will need to run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jxl verify requirements --git-url=https://github.com/myorg/environment-mycluster-staging.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will ensure that your &lt;code&gt;jx-requirements.yml&lt;/code&gt; file in your &lt;code&gt;staging&lt;/code&gt; / &lt;code&gt;production&lt;/code&gt; git repository is setup to point at the correct cloud resources.&lt;/p&gt;
&lt;p&gt;Then follow the &lt;a href=&#34;/docs/labs/boot/getting-started/secrets/&#34;&gt;secrets setup&lt;/a&gt; and  &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;run the boot job&lt;/a&gt; for the &lt;code&gt;staging&lt;/code&gt; / &lt;code&gt;production&lt;/code&gt; environment&lt;/p&gt;
&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;
&lt;p&gt;Once you run &lt;code&gt;jx boot&lt;/code&gt; on your development cluster you will get a helm 3 based installation of Jenkins X as usual but with a few differences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;Environment&lt;/code&gt; resources for &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; marked as &lt;code&gt;remote&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;SourceRepository&lt;/code&gt; resources for &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; will reference the &lt;code&gt;pr-only&lt;/code&gt; &lt;code&gt;Scheduler&lt;/code&gt; which means only the Pull Request pipelines will run on the development cluster; the release pipelines will run in the remote cluster.&lt;/li&gt;
&lt;li&gt;the git repository for the &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; environments will use the helmfile + helm 3 layout structure (using an &lt;code&gt;apps&lt;/code&gt; folder instead of &lt;code&gt;env&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;setting-up-the-remote-stagingproduction-cluster&#34;&gt;Setting up the remote Staging/Production cluster&lt;/h3&gt;
&lt;p&gt;First make a note of the git repository locations of your &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; environments via the &lt;a href=&#34;https://jenkins-x.io/commands/jx_get_environments/&#34;&gt;jx get env&lt;/a&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx get env
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now follow the &lt;a href=&#34;https://jenkins-x.io/docs/getting-started/setup/create-cluster/&#34;&gt;usual steps to create your kubernetes cluster&lt;/a&gt; and connect to the cluster so that &lt;code&gt;kubectl get node&lt;/code&gt; runs against the &lt;code&gt;Staging&lt;/code&gt; or &lt;code&gt;Production&lt;/code&gt; cluster you want to setup.&lt;/p&gt;
&lt;p&gt;Then git clone the git repository for the &lt;code&gt;Staging&lt;/code&gt; / &lt;code&gt;Production&lt;/code&gt; environment and &lt;code&gt;cd&lt;/code&gt; into the directory.&lt;/p&gt;
&lt;p&gt;Now run &lt;code&gt;jx boot&lt;/code&gt; in the usual way&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx boot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And your remote &lt;code&gt;Staging&lt;/code&gt; or &lt;code&gt;Production&lt;/code&gt; cluster should boot up.&lt;/p&gt;
&lt;p&gt;If you want to add any more apps to your cluster, use the &lt;a href=&#34;/docs/labs/boot/apps/#adding-apps-or-charts&#34;&gt;jx add app&lt;/a&gt; command.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Progressive Delivery</title>
      <link>/docs/labs/boot/progressive-delivery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/progressive-delivery/</guid>
      <description>
        
        
        &lt;p&gt;Progressive delivery allows you to gradually rollout new versions of your application to an environment using &lt;em&gt;canaries&lt;/em&gt; and gradually giving traffic to the new version until you are happy to fully rollover to the new version.&lt;/p&gt;
&lt;p&gt;Our recommendation for using progressive delivery with Jenkins X is to use:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://flagger.app/&#34;&gt;flagger&lt;/a&gt; as the progressive delivery controller&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/&#34;&gt;istio&lt;/a&gt; as the service mesh to provider advanced load balancing capabilities across internal or external networking&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;configuring-progressive-delivery&#34;&gt;Configuring Progressive Delivery&lt;/h2&gt;
&lt;p&gt;Please follow the usual &lt;a href=&#34;/docs/labs/boot/getting-started/&#34;&gt;getting started guide for boot and helm 3&lt;/a&gt; but before &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;running boot&lt;/a&gt; please make sure you make the following configuration:&lt;/p&gt;
&lt;h3 id=&#34;add-the-istio-and-flagger-apps&#34;&gt;Add the istio and flagger apps&lt;/h3&gt;
&lt;p&gt;Please make sure your &lt;code&gt;jx-apps.yml&lt;/code&gt; has the necessary apps for using &lt;a href=&#34;https://flagger.app/&#34;&gt;flagger&lt;/a&gt; and &lt;a href=&#34;https://istio.io/&#34;&gt;istio&lt;/a&gt;. Your &lt;code&gt;jx-apps.yml&lt;/code&gt; in your development environment git repository should look something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apps&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: jx-labs/istio
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: flagger/flagger
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: flagger/grafana
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: jx-labs/flagger-metrics
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: stable/kuberhealthy
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So that you remove &lt;code&gt;stable/nginx-ingress&lt;/code&gt; from your &lt;code&gt;jx-apps.yml&lt;/code&gt; file and ensure the above apps are added at the top of the file.&lt;/p&gt;
&lt;p&gt;Also for now I&amp;rsquo;m afraid you will have to remove the &lt;code&gt;jenkins-x/jxui&lt;/code&gt; chart as its currently not working yet with istio ingress - but we can hopefully get that working soon.&lt;/p&gt;
&lt;h3 id=&#34;enable-istio-based-ingress&#34;&gt;Enable istio based ingress&lt;/h3&gt;
&lt;p&gt;To avoid having 2 &lt;code&gt;LoadBalancer&lt;/code&gt; services for both &lt;code&gt;istio&lt;/code&gt; and &lt;code&gt;nginx&lt;/code&gt; (which costs more money) its easier to switch to pure istio for both internal and external load balancing. This also results in a smaller footprint.&lt;/p&gt;
&lt;p&gt;To do that ensure that &lt;code&gt;kind: istio&lt;/code&gt; is added to the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file in the top level &lt;code&gt;ingress:&lt;/code&gt; section like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;domain&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: istio
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;now-boot&#34;&gt;Now boot&lt;/h3&gt;
&lt;p&gt;Now your development git repository should be setup and be ready. Now:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;make sure you have setup &lt;a href=&#34;/docs/labs/boot/getting-started/secrets/&#34;&gt;any secrets you need to boot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;now &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;run boot&lt;/a&gt; to setup your installation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When it is all complete you should see istio, flagger, grafana pods running in the &lt;code&gt;istio-system&lt;/code&gt; namespace something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl get pod -n istio-system
NAME                                    READY   STATUS    RESTARTS   AGE
flagger-66dc49cd-g6ptp                  1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
grafana-7d7d7476f6-ff6bm                1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
istio-ingressgateway-598796f4d9-sq8b7   1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
istiod-7d9c7bdd6-vjp9j                  1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
kuberhealthy-f54f7f7df-b5gbf            1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;          32h
kuberhealthy-f54f7f7df-j6qwt            1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
prometheus-b47d8c58c-n974m              2/2     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          32h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;From 1.5 onwards istio is pretty small; just 2 pods. Note that those &lt;code&gt;kuberhealthy&lt;/code&gt; pods are optional and just help with reporting.&lt;/p&gt;
&lt;h3 id=&#34;enable-istio-in-stagingproduction&#34;&gt;Enable istio in staging/production&lt;/h3&gt;
&lt;p&gt;If you wish to use a Canary with &lt;a href=&#34;https://flagger.app/&#34;&gt;flagger&lt;/a&gt; and &lt;a href=&#34;https://istio.io/&#34;&gt;istio&lt;/a&gt; in your staging or production namespace you need to make sure you have labelled the namespace correctly to enable istio injection.&lt;/p&gt;
&lt;p&gt;To enable istio in staging:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl label namespace jx-staging istio-injection&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To enable istio in production:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl label namespace jx-production istio-injection&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;defaulting-to-use-canary&#34;&gt;Defaulting to use Canary&lt;/h3&gt;
&lt;p&gt;Run the following command to default to using canary deployments and horizontal pod autoscaling whenever you &lt;a href=&#34;/docs/getting-started/first-project/create-quickstart/&#34;&gt;create a new quickstart&lt;/a&gt; or &lt;a href=&#34;/docs/using-jx/creating/import/&#34;&gt;import a project&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jxl edit deploy --team --canary --hpa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will enable all new quickstarts and imported projects to use canary rollouts and use horizontal pod autoscaling in all environments.&lt;/p&gt;
&lt;p&gt;You can switch the defaults back again at any time or configure any app to change its defaults by running &lt;code&gt;jxl edit deploy&lt;/code&gt; inside a git clone of an application.&lt;/p&gt;
&lt;h3 id=&#34;enablingdisabling-canaryhpa-in-an-environment&#34;&gt;Enabling/Disabling Canary/HPA in an Environment&lt;/h3&gt;
&lt;p&gt;If you want to enable/disable canary or horizontal pod autoscaling for a specific app in an environment then you can &lt;a href=&#34;/docs/labs/boot/apps/#customising-charts&#34;&gt;follow the app customisation approach&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Assuming your app is called &lt;code&gt;myapp&lt;/code&gt; then in the git repository for the environment (e.g. &lt;code&gt;Staging&lt;/code&gt;) you can add/edit a file called &lt;code&gt;apps/mychart/values.yaml&lt;/code&gt; to look like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;canary&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;hpa&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;you can enable/disable those 2 flags for canary releases and horizontal pod autoscaler at any point in any environment.&lt;/p&gt;
&lt;h2 id=&#34;using-progressive-delivery&#34;&gt;Using Progressive Delivery&lt;/h2&gt;
&lt;p&gt;Once you have followed the above steps create a &lt;a href=&#34;/docs/getting-started/first-project/create-quickstart/&#34;&gt;quickstart application&lt;/a&gt; in the usual way.&lt;/p&gt;
&lt;p&gt;As you merge changes to the master branch of your application Jenkins X will create a new release and &lt;a href=&#34;/docs/using-jx/faq/#how-does-promotion-actually-work&#34;&gt;promote it to the staging environment&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However if Canary deployment is enabled your new version will gradually be rolled out progressively:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the defaults are that 20% of the traffic will go to the new version&lt;/li&gt;
&lt;li&gt;flagger will keep monitoring the metrics used in the Canary resource to determine if the canary is good&lt;/li&gt;
&lt;li&gt;after the configured time period is over the traffic will be increased to 40% then 60%&lt;/li&gt;
&lt;li&gt;eventually if things look good the new version will fully rollout to 100% traffic&lt;/li&gt;
&lt;li&gt;if anything goes bad during the rollout time period the old version is restored&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is an excellent &lt;a href=&#34;https://youtu.be/7eePqtxW7NM&#34;&gt;video showing this in action&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Benefits</title>
      <link>/docs/labs/boot/benefits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/benefits/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;We can use vanilla helm 3 now to install, update or delete charts in any namespace without needing tiller or custom code to manage &lt;code&gt;helm template&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;We can avoid all the complexities of the &lt;code&gt;jx step helm apply&lt;/code&gt; logic using our own helm template generation + post processing logic. We can also move away from boot&amp;rsquo;s use of &lt;code&gt;{{ .Requirements.foo }}&lt;/code&gt; and &lt;code&gt;{{ .Parameters.bar }}&lt;/code&gt; expressions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It opens the door to a flexible &lt;a href=&#34;/docs/labs/boot/multi-cluster/&#34;&gt;multi-cluster support&lt;/a&gt; so that every cluster/environment can be managed in the same canonical GitOps approach (as each cluster can use &lt;code&gt;jx boot&lt;/code&gt; whether its a dev environment or remote staging/production environment)&lt;/li&gt;
&lt;li&gt;We can use the &lt;code&gt;helm list&lt;/code&gt; command line to view versions of each chart/app nicely in the CLI.
&lt;ul&gt;
&lt;li&gt;we can avoid composite charts to simplfiy configuration and upgrades&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Everything is now an app. So if you want to remove our &lt;code&gt;nginx-ingress&lt;/code&gt; chart and replace it with another ingress solution (knative / istio / gloo / ambassador / linkerd or whatever) just go ahead and use the &lt;a href=&#34;/docs/labs/boot/apps/&#34;&gt;apps commands&lt;/a&gt; to add/remove apps and have boot manage everything in a consistent way
&lt;ul&gt;
&lt;li&gt;e.g. here&amp;rsquo;s &lt;a href=&#34;https://github.com/jstrachan/environment-bucketrepo-dev/blob/master/jx-apps.yml#L2-L5&#34;&gt;an example&lt;/a&gt; of removing &lt;code&gt;nginx&lt;/code&gt;, &lt;code&gt;chartmusem&lt;/code&gt; and &lt;code&gt;nexus&lt;/code&gt; and adding in &lt;code&gt;istio&lt;/code&gt;, &lt;code&gt;flagger&lt;/code&gt; and some other tools like &lt;code&gt;bucketrepo&lt;/code&gt; and &lt;code&gt;kuberhealthy&lt;/code&gt; via a single simple yaml change. Incidentally to replace the use of &lt;code&gt;Ingress&lt;/code&gt; resources with istio&amp;rsquo;s &lt;code&gt;Gateway&lt;/code&gt; and &lt;code&gt;VirtualService&lt;/code&gt; you also need to add the &lt;code&gt;kind: istio&lt;/code&gt; flag in the &lt;a href=&#34;https://github.com/jstrachan/environment-bucketrepo-dev/blob/master/jx-requirements.yml#L57&#34;&gt;jx-requirements.yml&lt;/a&gt; file&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;You can install an app in a specific namespace if you wish
&lt;ul&gt;
&lt;li&gt;This also opens the door to using boot to setup multi-team installations where multiple teams use different namespaces but share services in the same cluster&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The new &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;jxl boot run&lt;/a&gt; command runs the boot pipeline as a &lt;code&gt;Job&lt;/code&gt; inside the Kubernetes cluster. This ensures consistency in tooling used and also improves security by avoiding having the secrets on a developers laptop.&lt;/li&gt;
&lt;li&gt;The boot git repository is much smaller and simpler; less to keep in sync/rebase/merge with the upstream git repository. Its mostly just 2 YAML files now &lt;code&gt;jx-requirements.yml&lt;/code&gt; and &lt;code&gt;jx-apps.yml&lt;/code&gt; which are both pretty much specific to your cluster installation. The &lt;code&gt;jenkins-x.yml&lt;/code&gt; pipeline is configured inside the build pack so usually is 1 simple line long. So there&amp;rsquo;s no need for all the git merge/rebase/cherry pick logic in jx 2.x
&lt;ul&gt;
&lt;li&gt;we rely more instead on the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; which can be shared across installations&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;the boot process is split up into &lt;a href=&#34;/docs/labs/boot/getting-started/&#34;&gt;separate phases&lt;/a&gt; which makes things easier to iterate and configure:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/docs/labs/boot/getting-started/cloud/&#34;&gt;setting up the cloud resources&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/docs/labs/boot/getting-started/repository/&#34;&gt;creating the git repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/docs/labs/boot/getting-started/secrets/&#34;&gt;setting up secrets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;running the boot Job&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;we no longer use &lt;code&gt;exposecontroller&lt;/code&gt; and use regular helm configuration to create &lt;code&gt;Ingress&lt;/code&gt; resources and &lt;a href=&#34;/docs/labs/boot/faq/#how-do-i-configure-the-ingress-domain-in-dev-staging-or-production&#34;&gt;override domain names&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;secret handling is currently much simpler:
&lt;ul&gt;
&lt;li&gt;You can specify all the secrets &lt;a href=&#34;/docs/labs/boot/getting-started/secrets/&#34;&gt;setup up the secrets&lt;/a&gt; before &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;running the boot Job&lt;/a&gt; by importing a &lt;code&gt;secrets.yaml&lt;/code&gt; or entering them directly&lt;/li&gt;
&lt;li&gt;we support Google Secret Manager or a Kubernetes Secret current; but this simple &lt;a href=&#34;https://github.com/jenkins-x-labs/helmboot/blob/master/pkg/secretmgr/interface.go#L5&#34;&gt;SecretManager&lt;/a&gt; interface should be super easy to implement for other cloud secrets providers or managed vault installations.&lt;/li&gt;
&lt;li&gt;the simpler secrets handling means we can run the &lt;a href=&#34;/docs/labs/boot/getting-started/run/&#34;&gt;running the boot Job&lt;/a&gt; inside the kubernetes cluster for better security&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Comparison</title>
      <link>/docs/labs/boot/comparison/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/comparison/</guid>
      <description>
        
        
        &lt;p&gt;This document outlines the similarities and differences of the helmfile / helm 3 approach for those who are aware of &lt;code&gt;jx boot&lt;/code&gt; with helm 2.&lt;/p&gt;
&lt;h2 id=&#34;similarities-with-jx-boot-and-helm-2&#34;&gt;Similarities with &lt;code&gt;jx boot&lt;/code&gt; and helm 2&lt;/h2&gt;
&lt;p&gt;Just like classic boot with the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/&#34;&gt;jenkins-x-boot-config&lt;/a&gt; git repository, this new &lt;a href=&#34;https://github.com/roboll/helmfile&#34;&gt;helmfile&lt;/a&gt; solution supports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;you can run &lt;code&gt;jx boot&lt;/code&gt; to spin up a new git repository for your development environment&lt;/li&gt;
&lt;li&gt;you can run &lt;code&gt;jx boot&lt;/code&gt; at any time to reapply changes from your laptop or can trigger a CI/CD pipeline using tekton to do the same thing&lt;/li&gt;
&lt;li&gt;the git repository contains a &lt;code&gt;jenkins-x.yml&lt;/code&gt; to implement the boot pipeline&lt;/li&gt;
&lt;li&gt;a YAML file is used to store all the charts that are applied using &lt;code&gt;jx boot&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;differences-with-jx-boot-and-helm-3&#34;&gt;Differences with &lt;code&gt;jx boot&lt;/code&gt; and helm 3&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;we use helm 3 along with &lt;a href=&#34;https://github.com/roboll/helmfile&#34;&gt;helmfile&lt;/a&gt; to actually apply the helm charts into a kubernetes cluster&lt;/li&gt;
&lt;li&gt;any helm chart can be deployed in any namespace (previously we used 1 namespace for all charts in the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/requirements.yaml&#34;&gt;env/requirements.yaml&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;we no longer use a composite chart for &lt;code&gt;env/Chart.yaml&lt;/code&gt; and instead deploy each chart independently
&lt;ul&gt;
&lt;li&gt;this means that each chart has its own unique version number; so that &lt;code&gt;helm list&lt;/code&gt; gives nice meaningful results&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;we have done away with the complexity of &lt;code&gt;jenkins-x-platform&lt;/code&gt; (a composite chart containing logs of &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform/blob/master/jenkins-x-platform/requirements.yaml&#34;&gt;dependencies&lt;/a&gt; like &lt;code&gt;jenkins&lt;/code&gt; + &lt;code&gt;chartmuseum&lt;/code&gt; + &lt;code&gt;nexus&lt;/code&gt; etc) so that each chart can be added/removed independently or swapped out with a different version/distribution&lt;/li&gt;
&lt;li&gt;instead of using &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/requirements.yaml&#34;&gt;env/requirements.yaml&lt;/a&gt; we now use a simple and more powerful &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/jx-apps.yml&#34;&gt;jx-apps.yml&lt;/a&gt; file which is similar but supports:
&lt;ul&gt;
&lt;li&gt;we can specify a &lt;code&gt;namespace&lt;/code&gt; on any chart&lt;/li&gt;
&lt;li&gt;we can add extra &lt;code&gt;valuesFiles&lt;/code&gt; to use with the chart to override the helm &lt;code&gt;values.yaml&lt;/code&gt; files&lt;/li&gt;
&lt;li&gt;different &lt;code&gt;phase&lt;/code&gt; values so that we can default some charts like &lt;code&gt;nginx-ingress&lt;/code&gt; to the &lt;code&gt;system&lt;/code&gt; phase before we setup ingress, DNS, TLS and certs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;instead of copying lots of &lt;code&gt;env/$appName/values*.yaml&lt;/code&gt; files into the boot config like we do in &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/&#34;&gt;these folders&lt;/a&gt; such as &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/lighthouse/values.tmpl.yaml&#34;&gt;the lighthouse/values.tmpl.yaml&lt;/a&gt; we can instead default all of these from the version stream at &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/tree/master/apps/jenkins-x/lighthouse&#34;&gt;apps/jenkins-x/lighthouse&lt;/a&gt; - which means the boot config git repository is much simpler, we can share more configuration with the version stream and it avoids lots of git merge/rebase issues.&lt;/li&gt;
&lt;li&gt;since we are using helm 3 directly you can add/remove apps and re-run &lt;code&gt;jx boot&lt;/code&gt; and things are removed correctly.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Apps framework</title>
      <link>/docs/labs/boot/apps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/apps/</guid>
      <description>
        
        
        &lt;p&gt;The new &lt;a href=&#34;https://github.com/roboll/helmfile&#34;&gt;helmfile&lt;/a&gt; and helm 3 approach extends the app extension model in Jenkins X.&lt;/p&gt;
&lt;p&gt;In essence that means if you are using helmfile you can use the usual Apps commands which create Pull Requests on the &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/jx-apps.yml&#34;&gt;jx-apps.yml&lt;/a&gt; file in your environments git repository rather than the traditional &lt;code&gt;env/requirements.yaml&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;This also means you can have apps in different namespaces. e.g. its common to put some charts in different namespaces like &lt;code&gt;nginx-ingress&lt;/code&gt;, &lt;code&gt;gloo&lt;/code&gt;, &lt;code&gt;cert-mangager&lt;/code&gt; etc.&lt;/p&gt;
&lt;h3 id=&#34;viewing-apps&#34;&gt;Viewing apps&lt;/h3&gt;
&lt;p&gt;You can view your apps across all namespaces via &lt;a href=&#34;https://jenkins-x.io/commands/jx_get_apps/&#34;&gt;jx get app&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jxl get app
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will effectively display data from the &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/jx-apps.yml&#34;&gt;jx-apps.yml&lt;/a&gt;. This data will be pretty close to using a regular &lt;code&gt;helm list&lt;/code&gt; using helm 3.x or later; only it will show apps across all namespaces by default..&lt;/p&gt;
&lt;h3 id=&#34;adding-apps-or-charts&#34;&gt;Adding apps or charts&lt;/h3&gt;
&lt;p&gt;you can use &lt;a href=&#34;https://jenkins-x.io/commands/jx_add_app/&#34;&gt;jxl add app&lt;/a&gt; to add any helm chart to your installation using the usual helm style notation of &lt;code&gt;repositoryPrefix/chartName&lt;/code&gt; such as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jxl add app jetstack/cert-manager
jxl add app flagger/flagger

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;these commands will implicitly use the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; configuration (via &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/blob/master/charts/repositories.yml&#34;&gt;charts/repositories.yml&lt;/a&gt;) to determine the mapping of prefixes to repository URLs.&lt;/p&gt;
&lt;p&gt;Then these commands will create Pull Requests on the &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/jx-apps.yml&#34;&gt;jx-apps.yml&lt;/a&gt; file in your environments git repository.&lt;/p&gt;
&lt;p&gt;Note that usually the Pull Request will only add a simple line of the format to the &lt;code&gt;apps:&lt;/code&gt; entry:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apps:
- name: jetstack/cert-manager 
- name: flagger/flagger
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This keeps the configuration in the environment git repository nice and concise. The &lt;code&gt;version&lt;/code&gt; of the chart is then resolved during deployment via the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;adding-new-kubernetes-resources&#34;&gt;Adding new kubernetes resources&lt;/h3&gt;
&lt;p&gt;Sometimes you just want to add one or more kubernetes resources such as an &lt;code&gt;Ingress&lt;/code&gt; or &lt;code&gt;ConfigMap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Helmfile supports using helm charts in source code format; so its easy to add any kubernetes resources directly via YAML files.&lt;/p&gt;
&lt;p&gt;e.g. if you look in the &lt;code&gt;repositories/templates&lt;/code&gt; folder you will see at least one YAML resource. So you could just add more YAML files to that folder.&lt;/p&gt;
&lt;p&gt;Though you may want to separate out your resources into their own chart; so you could add a new folder structure like the &lt;code&gt;resources&lt;/code&gt; folder. e.g. add these files:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mythings/
  Chart.yaml
  templates/
     some-resource.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then to reference &lt;code&gt;mythings&lt;/code&gt; add the following to your &lt;code&gt;jx-apps.yml&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: mythings
  repository: &amp;quot;..&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then longer term if you want to turn your chart &lt;code&gt;mythings&lt;/code&gt; into a released chart you could create a new git repository and move the folder there, then just remove the &lt;code&gt;repository:&lt;/code&gt; entry in the &lt;code&gt;jx-apps.yml&lt;/code&gt; to reference the released chart instead.&lt;/p&gt;
&lt;h3 id=&#34;customising-charts&#34;&gt;Customising charts&lt;/h3&gt;
&lt;p&gt;You can add custom &lt;code&gt;values.yaml&lt;/code&gt; files for a chart by adding the file to &lt;code&gt;apps/mychart/values.yaml&lt;/code&gt;. This file will then be referenced in the generated &lt;code&gt;apps/helmfile.yaml&lt;/code&gt; file and passed into &lt;code&gt;helm&lt;/code&gt; when you next run &lt;code&gt;jxl boot run&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can also use a file called &lt;code&gt;values.yaml.gotmpl&lt;/code&gt; if you wish to use go templating of the values file. For example this lets you reference properties from the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file via expressions like &lt;code&gt;{{ .Values.jxRequirements.ingress.domain }}&lt;/code&gt;. You can also reference the shared secrets in your &lt;code&gt;values.yaml.gotmpl&lt;/code&gt; file via &lt;code&gt;{{ .Values.secrets.pipelineUser.username }}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To see an example of this in action check out the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/tree/master/apps/jenkins-x/tekton/values.yaml.gotmpl&#34;&gt;apps/jenkins-x/tekton/values.yaml.gotmpl&lt;/a&gt; file in the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note that many apps are already configured to make use of the &lt;code&gt;jx-requirements.yml&lt;/code&gt; settings via the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; - but you are free to add your own custom configuration.&lt;/p&gt;
&lt;h3 id=&#34;removing-apps&#34;&gt;Removing apps&lt;/h3&gt;
&lt;p&gt;To remove an app use &lt;a href=&#34;https://jenkins-x.io/commands/jx_delete_app/&#34;&gt;jx delete app&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jxl delete app jetstack/cert-manager
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Background</title>
      <link>/docs/labs/boot/background/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/background/</guid>
      <description>
        
        
        &lt;p&gt;see the &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/6442&#34;&gt;issue&lt;/a&gt; and &lt;a href=&#34;https://github.com/jenkins-x/enhancements/tree/master/proposals/2&#34;&gt;enhancement proopsal&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;
&lt;p&gt;We want a simple canonical way to install any helm chart in any namespace without having to manually hack the &lt;code&gt;jx boot&lt;/code&gt; pipeline file: &lt;code&gt;jenkins-x.yml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This will make it easy for people or software to easily add/remove apps to any git repository for any Environment (dev / staging / production).&lt;/p&gt;
&lt;p&gt;The boot config repo has become quite complex and hard to manage upgrades to and share common config between different flavours of base boot config repos.  It’s also hard to experiment by adding new helm charts / features / applications that require changes to the boot install pipeline.&lt;/p&gt;
&lt;p&gt;We want a simpler more modular system that lets us, say, swap out nginx-controller and use gloo/knative/istio for ingress without a deep knowledge of the jenkins-x.yml pipeline for boot.&lt;/p&gt;
&lt;p&gt;What we’d really like is for folks to type commands like…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx delete app nginx-controller
jx add app istio
jx delete app knative
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And for it to just work and generically add those to the right namespace.&lt;/p&gt;
&lt;h2 id=&#34;current-limitations&#34;&gt;Current Limitations&lt;/h2&gt;
&lt;p&gt;The current apps model lets you add/remove charts fine - but there are a number of limitations:&lt;/p&gt;
&lt;h3 id=&#34;only-works-in-1-namespace&#34;&gt;Only works in 1 namespace&lt;/h3&gt;
&lt;p&gt;Currently apps can only work inside the dev namespace - we can’t support things like knative, gloo, cert-manager, nginx, velero which tend to be installed in separate namespaces.&lt;/p&gt;
&lt;p&gt;### Does not handle boot phases&lt;/p&gt;
&lt;p&gt;This is not surprising as we created the App extension model before boot. But right now boot has a number of distinct phases with pipeline steps between them where we may want to add apps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pre/post ingress setup (in the case of nip.io / nginx-controller)&lt;/li&gt;
&lt;li&gt;pre/post vault setup&lt;/li&gt;
&lt;li&gt;pre/post vault population of parameters&lt;/li&gt;
&lt;li&gt;pre/post setup of certmanager/external dns&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is currently no way for an apps to specify a namespace + specify which phase its to be installed in &amp;amp; have (say) the domain / certs / secrets injected easily.&lt;/p&gt;
&lt;p&gt;So rather than adding steps at the right point in a list of steps in the jenkins-x.yml it would be nice to have a more declarative YAML file to describe which apps are to be enabled.&lt;/p&gt;
&lt;p&gt;E.g. we need a new YAML file with list of charts to be installed along with metadata for which phase to install them. We also want to invoke a selection of those appss to be installed at the different phases of the boot pipeline.&lt;/p&gt;
&lt;h3 id=&#34;limitations-of-the-current-deploy-model&#34;&gt;Limitations of the current deploy model&lt;/h3&gt;
&lt;p&gt;We have some issues with the current way we deploy apps in Staging / Production:&lt;/p&gt;
&lt;h4 id=&#34;composite-charts-hide-the-individual-versions&#34;&gt;Composite charts hide the individual versions&lt;/h4&gt;
&lt;p&gt;Right now we deploy all charts in Staging/Production as a single chart. That means if you use &lt;code&gt;helm list&lt;/code&gt; we don&amp;rsquo;t show any actual versions of the dependent charts - its just 1 chart (with no version).&lt;/p&gt;
&lt;h4 id=&#34;removing-apps-on-dev-doesnt-work&#34;&gt;Removing Apps on Dev doesn&amp;rsquo;t work&lt;/h4&gt;
&lt;p&gt;If you remove a chart from &lt;code&gt;env/requirements.yaml&lt;/code&gt;  in the Dev repository the pipeline does not remove the chart. e.g. if you add &lt;code&gt;lighthouse&lt;/code&gt; and remove &lt;code&gt;prow&lt;/code&gt; you need to manually delete the prow resources yourself.&lt;/p&gt;
&lt;h3 id=&#34;limitation-of-boot&#34;&gt;Limitation of boot&lt;/h3&gt;
&lt;p&gt;We currently manually configure in the boot pipeline the install of multiple systems usually in separate namespaces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;velero (if enabled)&lt;/li&gt;
&lt;li&gt;nginx&lt;/li&gt;
&lt;li&gt;externaldns&lt;/li&gt;
&lt;li&gt;cert-manager&lt;/li&gt;
&lt;li&gt;acme certs chart&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ideally those should be modular and optional. e.g it should be really trivial to disable nginx if folks are using, say, istio - without having to hack a pipeline yaml.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;d also like to make it easy to add a number of other systems in order in separate namespaces independently of the &lt;code&gt;Staging / Production&lt;/code&gt; environment namespaces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;knative &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/6331&#34;&gt;https://github.com/jenkins-x/jx/issues/6331&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gloo&lt;/li&gt;
&lt;li&gt;istio&lt;/li&gt;
&lt;li&gt;linkerd &lt;a href=&#34;https://github.com/jenkins-x/jx/issues/6330&#34;&gt;https://github.com/jenkins-x/jx/issues/6330&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;flagger&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so it&amp;rsquo;d be nice to have a simple app model where anyone can add any systems/charts to any namespace at any point in the flow before we setup the dev/staging/production environment in the traditional way.&lt;/p&gt;
&lt;h2 id=&#34;proposal&#34;&gt;Proposal&lt;/h2&gt;
&lt;p&gt;We propose we combine the extensibility of Jenkins X using Apps with &lt;code&gt;jx boot&lt;/code&gt; via a simple declarative YAML file declaring the charts to be installed.&lt;/p&gt;
&lt;p&gt;e.g. a file &lt;code&gt;apps.yaml&lt;/code&gt;  something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;defaultNamespace&lt;/span&gt;: jx

&lt;span style=&#34;color:#66d9ef&#34;&gt;releases&lt;/span&gt;: 
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: velero
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: velero
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://kubernetes-charts.storage.googleapis.com
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: system  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: velero   
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: nginx-ingress
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: nginx-ingress
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://kubernetes-charts.storage.googleapis.com
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: system  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: kube-system   
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: external-dns
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://charts.bitnami.com/bitnami
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: post-ingress  
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: cert-manager
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: cert-manager
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://charts.jetstack.io
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: cert-manager  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: post-ingress  
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: jxboot-resources
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: tekton
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: tekton
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: prow
  &lt;span style=&#34;color:#66d9ef&#34;&gt;condition&lt;/span&gt;: prow.enabled
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: prow
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: lighthouse
  &lt;span style=&#34;color:#66d9ef&#34;&gt;condition&lt;/span&gt;: lighthouse.enabled
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: lighthouse
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;alias&lt;/span&gt;: bucketrepo
  &lt;span style=&#34;color:#66d9ef&#34;&gt;condition&lt;/span&gt;: bucketrepo.enabled
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: bucketrepo
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: jenkins-x-platform
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: http://chartmuseum.jenkins-x.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Using a yaml file in a boot config repo we list the apps that should be installed.  This means we can instead have a bare minimum base boot config repo and list the apps we want installed and different points of the installation process.&lt;/p&gt;
&lt;p&gt;The above YAML looks quite like the &lt;code&gt;env/requirements.yaml&lt;/code&gt; file only:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it allows the &lt;code&gt;namespace&lt;/code&gt; to be specified if its different from the &lt;code&gt;defaultNamespace&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;we add the &lt;code&gt;phase&lt;/code&gt; label so that we can filter the apps by phase so we can install different charts at different points in the boot pipeline.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;### Strawman Solutions&lt;/p&gt;
&lt;p&gt;The above &lt;code&gt;apps.yaml&lt;/code&gt; proposal looks very much like helmfile.&lt;/p&gt;
&lt;p&gt;So lets look into helmfile and try using it with a stripped back boot config repo to see how things might fit together&lt;/p&gt;
&lt;p&gt;One possible solution might be to add a single step the boot pipeline to invoke helmfile: &lt;a href=&#34;https://github.com/roboll/helmfile#configuration&#34;&gt;https://github.com/roboll/helmfile#configuration&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;e.g. given the &lt;code&gt;apps.yaml&lt;/code&gt; file in the file system then run helmfile as a step on the file.&lt;/p&gt;
&lt;p&gt;It looks like helmfile already supports tillerless + helm3 and lets us define namespaces and orders etc.&lt;/p&gt;
&lt;p&gt;We may need to build our own step to wrap helmfile so that we can do some of the things we do with &lt;code&gt;jx step helm apply&lt;/code&gt; right now (e.g. exposing the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file as a &lt;code&gt;values.yaml&lt;/code&gt; its values can be used inside any &lt;code&gt;values.yaml&lt;/code&gt; we use in the charts).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;should we support access to secrets in vault / local file system via URLs or Parameters injection?&lt;/li&gt;
&lt;li&gt;do we need to support exposing the properties from the &lt;code&gt;jx-requirements.yml&lt;/code&gt; as values.yaml files that can be reused inside the helmfile templates?&lt;/li&gt;
&lt;li&gt;do we need to improve access to certs / domain after we&amp;rsquo;ve set those up in boot?&lt;/li&gt;
&lt;li&gt;allow the use of version streams to manage versions of things if no version is specified in the &lt;code&gt;helmfile.yaml&lt;/code&gt; - like we do with helm charts requirements.yaml file right now (in &lt;code&gt;jx step helm apply&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So if we do need anything other than vanilla helmfile we could maybe do a similar thing to &lt;code&gt;jx step helm apply&lt;/code&gt; where we copy the directory where helmfile lives, then generate any secret yamls + &lt;code&gt;jx-requirements.yaml&lt;/code&gt; files and then run helmfile in a temporary directory (to avoid accidentally committing any secrets to git). Hopefully we don&amp;rsquo;t need to fork helmfile; but we could just wrap it slightly with a pre-processor?&lt;/p&gt;
&lt;p&gt;We want to allow the &lt;code&gt;jx boot&lt;/code&gt; pipeline to invoke a helmfile like thing at the different phases.&lt;/p&gt;
&lt;p&gt;e.g. currently in boot we do something like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;install a bunch of charts in different namespaces with a defined order&lt;/li&gt;
&lt;li&gt;then we modify the requirements based on ingress: &lt;code&gt;jx step create install values&lt;/code&gt; (to handle things like detecting the domain/ingress)&lt;/li&gt;
&lt;li&gt;install more charts (e.g. external dns/cert manager/vault)&lt;/li&gt;
&lt;li&gt;populate parameters/secrets (&lt;code&gt;jx step create values --name parameters&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;do the traditional install and maybe other charts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so we already have 3 natural places to invoke a helmfile-like thing to install charts in different phases. So maybe thats 3 places where we invoke helmfile with a selector as @vbehar mentions if thats something helmfile can do? or we use 3 separate helmfiles maybe?&lt;/p&gt;
&lt;p&gt;e.g. the pipeline with boot apps could be something like this&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx step helmfile --selector phase=pre-ingress

# populate ingress stuff (e.g. default domain from nip.io if not using custom domain)
jx step create install values

# add any charts that need a domain injected
jx step helmfile --selector phase=post-ingress


# populate any missing charts in vault
jx step create values --name parameters

# lets include generated secrets after they have been populated in vault
jx step helmfile --selector &amp;quot;!phase&amp;quot; --secrets
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we could have a list of apps which we group as to where they get added based on what they are &amp;amp; whether they need integration with secrets / TLS / domain / certs etc?&lt;/p&gt;
&lt;p&gt;We can then modify the existing &lt;code&gt;jx add app / jx delete app&lt;/code&gt; to detect the &lt;code&gt;apps.yaml&lt;/code&gt; file and create the necessary code change in a Pull Request.&lt;/p&gt;
&lt;p&gt;Maybe over time we move more towards this kind of helmfile-like approach for all environments too (&lt;code&gt;Dev&lt;/code&gt; / &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt;)?&lt;/p&gt;
&lt;h3 id=&#34;proposed-schedule&#34;&gt;Proposed Schedule&lt;/h3&gt;
&lt;p&gt;We can easily try a prototype a new boot config repo where we add helmfile and add some helmfile steps and see how it works and what we think of the general git source code &amp;amp; if it helps us and users have modular boot apps without committing to any significant changes in the jx repos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;try out helmfile for installing things like gloo / knative / linkerd / istio?&lt;/li&gt;
&lt;li&gt;if that works and we are happy with it, we could look at adding the phases approach for easier app composition&lt;/li&gt;
&lt;li&gt;if thats all looking good try migrate existing things like nginx / cert manager / external dns to the helmfile approach in a new git repository&lt;/li&gt;
&lt;li&gt;anyone can then try out the helmfile approach without changing the core upstream boot configuration &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/tree/master/env&#34;&gt;jenkins-x-boot-config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;we could try create a new remote cluster boot configuration for multi-cluster which installs a small subset of Jenkins X (e.g. lighthouse + tekton + a single &lt;code&gt;SourceRepository + Schedule&lt;/code&gt; for replicating the logic of the &lt;code&gt;environment controller&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;create a demo repository which replaces nginx-controller with knative + gloo we can use for Progressive Delivery demos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Maybe we find when we look at migrating the current charts to boot apps (nginx / cert manager / external-dns in particular) we may find its got some limitations and building a simple similar tool might be easier. Or we may find helmfile gets us where we need to go faster.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: How it works</title>
      <link>/docs/labs/boot/how-it-works/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/how-it-works/</guid>
      <description>
        
        
        &lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;
&lt;p&gt;The git repository for the (development) environment git repository looks like this&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx-requirements.yml   # the configuration of cluster, environments, storage, ingress etc
jx-apps.yml           # the list of apps to be installed
jenkins-x.yml         # the Jenkins X Pipeline to boot up Jenkins X
apps/
system/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We use the &lt;a href=&#34;https://github.com/jenkins-x-labs/boot-helmfile-poc/blob/master/jx-apps.yml&#34;&gt;jx-apps.yml&lt;/a&gt; file as source to generate 2 &lt;code&gt;helmfile.yaml&lt;/code&gt; files to perform the installation. This is done by the &lt;a href=&#34;https://jenkins-x.io/commands/jx_step_create_helmfile/&#34;&gt;jx step create helmfile&lt;/a&gt; command.&lt;/p&gt;
&lt;p&gt;After this command is run the git repository file system looks like this&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apps/
  helmfile.yaml
system/
  helmfile.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then the pipeline is effectively this (slightly simplifying for clarity):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx step verify preinstall
jx step create helmfile
cd system &amp;amp;&amp;amp; helmfile sync
jx step verify ingress
cd apps &amp;amp;&amp;amp; helmfile sync
jx step verify env
jx step verify install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So the pipeline is very similar to the traditional helm 2 boot pipeline. The main differences is the change to &lt;code&gt;helmfile sync&lt;/code&gt; to apply all the helm charts at the &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;apps&lt;/code&gt; phase. Also the helm 2 pipeline has lots of steps related to installing specific individual charts (nginx/velero/cert-manager/externaldns) - with the helmfile solution thats all done by the &lt;code&gt;jx-apps.yml&lt;/code&gt; file so we don&amp;rsquo;t need to touch the &lt;code&gt;jenkins-x.yml&lt;/code&gt; pipeline at all if we want to add/remove any apps.&lt;/p&gt;
&lt;h3 id=&#34;how-the-helmfileyaml-generation-works&#34;&gt;How the helmfile.yaml generation works&lt;/h3&gt;
&lt;p&gt;This is all done by the &lt;a href=&#34;https://jenkins-x.io/commands/jx_step_create_helmfile/&#34;&gt;jx step create helmfile&lt;/a&gt; command if you want to look at the code. Essentially we take that YAML file and parse it and use it to generate one of the helmfiles: &lt;code&gt;system/helmfile.yaml&lt;/code&gt; for system charts (installed before ingress, DNS, TLS and certs are setup and the domain is known) and any other charts in &lt;code&gt;apps/helmfile.yaml&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;defaulting-configuration&#34;&gt;Defaulting configuration&lt;/h4&gt;
&lt;p&gt;In an effort to try streamline the users boot configuration repository, we&amp;rsquo;ve tried to put as much common configuration into the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; as possible.&lt;/p&gt;
&lt;p&gt;For example the default &lt;code&gt;namespace&lt;/code&gt; for a chart and the &lt;code&gt;phase&lt;/code&gt; (whether its installed via the &lt;code&gt;system&lt;/code&gt; helmfile or the default &lt;code&gt;apps&lt;/code&gt; helmfile) can be specified in the &lt;code&gt;defaults.yml&lt;/code&gt; file in the version stream. e.g. here&amp;rsquo;s where we define the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/blob/master/apps/stable/nginx-ingress/defaults.yml&#34;&gt;apps/stable/nginx-ingress/defaults.yml&lt;/a&gt; for &lt;code&gt;nginx-ingress&lt;/code&gt;. This keeps the actual &lt;code&gt;jx-apps.yml&lt;/code&gt; nice and simple&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apps&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: stable/nginx-ingress
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Though if you really want you can be completely specific in your &lt;code&gt;jx-apps.yml&lt;/code&gt; file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apps&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: stable/nginx-ingress
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: https://kubernetes-charts.storage.googleapis.com
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: nginx
  &lt;span style=&#34;color:#66d9ef&#34;&gt;phase&lt;/span&gt;: system
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;valuesyaml-files&#34;&gt;values.yaml* files&lt;/h4&gt;
&lt;p&gt;In boot with helm 2 you can specify custom &lt;code&gt;values.yaml&lt;/code&gt; files or &lt;code&gt;values.tmpl.yaml&lt;/code&gt; (using go templates) files in a folder named after the chart in the &lt;code&gt;env&lt;/code&gt; folder in the git repository. e.g. here&amp;rsquo;s the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-boot-config/blob/master/env/tekton/values.tmpl.yaml&#34;&gt;env/tekton/values.tmpl.yaml&lt;/a&gt; file to customise tekton to the Jenkins X requirements and secrets.&lt;/p&gt;
&lt;p&gt;We use a similar approach of using &lt;code&gt;values.yaml&lt;/code&gt; files or templates - which in helmfile are called &lt;code&gt;values.yaml.gotmpl&lt;/code&gt; instead - which can be put in a folder named after the chart.&lt;/p&gt;
&lt;p&gt;So to do something similar in helmfile and helm 3 you could create an &lt;code&gt;apps/tekton/values.yaml.gotmpl&lt;/code&gt; file and it will be automatically picked up by &lt;a href=&#34;https://jenkins-x.io/commands/jx_step_create_helmfile/&#34;&gt;jx step create helmfile&lt;/a&gt; and referenced in the generated &lt;code&gt;apps/helmfile.yaml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However usually these &lt;code&gt;values.yaml*&lt;/code&gt; files we write for each chart are bindings to the &lt;code&gt;jx-requirements.yml&lt;/code&gt; and secrets and they usually don&amp;rsquo;t change between cluster installations.&lt;/p&gt;
&lt;p&gt;So we&amp;rsquo;ve allowed these files to be stored in the &lt;a href=&#34;https://jenkins-x.io/docs/concepts/version-stream/&#34;&gt;version stream&lt;/a&gt; instead. e.g. here&amp;rsquo;s the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/tree/master/apps/jenkins-x/tekton/values.yaml.gotmpl&#34;&gt;apps/jenkins-x/tekton/values.yaml.gotmpl&lt;/a&gt; file to customise the &lt;code&gt;tekton&lt;/code&gt; chart for use in Jenkins X with helmfile and helm 3.&lt;/p&gt;
&lt;p&gt;This helps keep the git repository for your (dev) environment much smaller and easier to manage. You can still override the &lt;code&gt;values.yaml*&lt;/code&gt; files for any app if you want inside your boot config git repository though..&lt;/p&gt;
&lt;h3 id=&#34;passing-in-jx-requirementsyml-and-secrets&#34;&gt;Passing in jx-requirements.yml and secrets&lt;/h3&gt;
&lt;p&gt;In boot with helm 2 we used &lt;a href=&#34;https://jenkins-x.io/docs/getting-started/setup/boot/how-it-works/#values-tmpl-yaml-templates&#34;&gt;some custom values in the values.yaml.tmpl files&lt;/a&gt; to inject values from the &lt;code&gt;jx-requirements.yml&lt;/code&gt; and secrets.&lt;/p&gt;
&lt;p&gt;To make it easier to use helmfile and helm 3 easily without any custom modifications we&amp;rsquo;ve used a slightly different approach:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;we turn the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file into a vanilla YAML file with the top level key &lt;code&gt;jxRequirements&lt;/code&gt; - the file is generated by the boot pipeline called &lt;code&gt;jx-requirements.values.yaml.gotmpl&lt;/code&gt; and referenced in the generated helmfiles. This means instead of expressions like &lt;code&gt;{{ .Requirements.cluster.provider }}&lt;/code&gt; you can use the vanilla helm expression of &lt;code&gt;{{ .Values.jxRequirements.cluster.provider }}&lt;/code&gt; in any &lt;code&gt;values.yaml.gotmpl&lt;/code&gt; you use in helmfile like in the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/blob/master/apps/jenkins-x/tekton/values.yaml.gotmpl#L8&#34;&gt;tekton values.yaml.gotmpl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;we put all secrets in a file called &lt;code&gt;secrets.yaml&lt;/code&gt; with a top level key of &lt;code&gt;secrets&lt;/code&gt; referenced by &lt;code&gt;$JX_SECRETS_DIR/secrets.yaml&lt;/code&gt;. This means we can change any old boot expressions of &lt;code&gt;{{ .Parameters.pipelineUser.token }}&lt;/code&gt; to the canonical helm expression &lt;code&gt;{{ .Values.secrets.pipelineUser.token }}&lt;/code&gt; like in this &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-versions/blob/master/apps/jenkins-x/tekton/values.yaml.gotmpl#L7&#34;&gt;tekton values.yaml.gotmpl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: FAQ</title>
      <link>/docs/labs/boot/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/labs/boot/faq/</guid>
      <description>
        
        
        &lt;h2 id=&#34;how-do-i-list-the-apps-that-have-been-deployed&#34;&gt;How do I list the apps that have been deployed?&lt;/h2&gt;
&lt;p&gt;You can use helm 3.x directly to list all the apps (charts) deployed in a namespace:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm list
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To look in another namespace add it as an argument:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm list -n nginx
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;how-do-i-customise-an-app-in-an-environment&#34;&gt;How do I customise an App in an Environment&lt;/h2&gt;
&lt;p&gt;With the new helm 3 based boot every environment uses boot - so there is a single way to configure anything whether its in the &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt; environment and whether or not you are using &lt;a href=&#34;/docs/labs/boot/multi-cluster/&#34;&gt;multiple clusters&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;See &lt;a href=&#34;/docs/labs/boot/apps/#customising-charts&#34;&gt;how to customise a chart&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;how-do-i-configure-the-ingress-domain-in-dev-staging-or-production&#34;&gt;How do I configure the ingress domain in Dev, Staging or Production?&lt;/h2&gt;
&lt;p&gt;With the new helm 3 based boot every environment uses boot - so there is a single way to configure anything whether its in the &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt; environment and whether or not you are using &lt;a href=&#34;/docs/labs/boot/multi-cluster/&#34;&gt;multiple clusters&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can override the domain name for use in all apps within an environment by modifying the &lt;code&gt;jx-requirements.yml&lt;/code&gt; in the git repository for the &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt; environment.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;domain&lt;/span&gt;: mydomain.com 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Also by default there is a namespace specific separator added. So if your service is &lt;code&gt;cheese&lt;/code&gt; the full domain name would be something like &lt;code&gt;cheese.jx-staging.mydomain.com&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you wish to avoid the namespace specific separator if each environment already has its own unique &lt;code&gt;domain&lt;/code&gt; value then you can specify:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;domain&lt;/span&gt;: mydomain.com  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespaceSubDomain&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you wish to change any of these values for a single app only then you can use the &lt;a href=&#34;/docs/labs/boot/apps/#customising-charts&#34;&gt;app customisation mechanism&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;e.g. for an app called &lt;code&gt;mychart&lt;/code&gt; you can create a file called &lt;code&gt;apps/mychart/values.yaml&lt;/code&gt; in the git repository for your environment and add the following YAML:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;jxRequirements&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;domain&lt;/span&gt;: mydomain.com  
    &lt;span style=&#34;color:#66d9ef&#34;&gt;namespaceSubDomain&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;how-do-i-configure-the-ingress-tls-certificate-in-dev-staging-or-production&#34;&gt;How do I configure the ingress TLS certificate in Dev, Staging or Production?&lt;/h2&gt;
&lt;p&gt;You can specify the TLS certificate to use for the &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt; environment by modifying the &lt;code&gt;jx-requirements.yml&lt;/code&gt; file in the environments git repository:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;: 
  &lt;span style=&#34;color:#66d9ef&#34;&gt;tls&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;secretName&lt;/span&gt;: my-tls-secret-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will then be applied to all the Jenkins X ingress resources for things like &lt;code&gt;lighthouse&lt;/code&gt; or &lt;code&gt;nexus&lt;/code&gt; - plus any apps you deploy to &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you want to override the TLS secret name for a specific app in a specific environment then rather like the &lt;a href=&#34;#how-do-i-configure-the-ingress-domain-in-dev-staging-or-production&#34;&gt;above question&lt;/a&gt; you can use the &lt;a href=&#34;/docs/labs/boot/apps/#customising-charts&#34;&gt;app customisation mechanism&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;e.g. for an app called &lt;code&gt;mychart&lt;/code&gt; you can create a file called &lt;code&gt;apps/mychart/values.yaml&lt;/code&gt; in the git repository for your environment and add the following YAML:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;jxRequirements&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;ingress&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;tls&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;secretName&lt;/span&gt;: my-tls-secret-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;how-do-i-uninstall-boot&#34;&gt;How do I uninstall boot?&lt;/h2&gt;
&lt;p&gt;From inside a git clone of your &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;staging&lt;/code&gt; or &lt;code&gt;production&lt;/code&gt; environment&amp;rsquo;s git repository you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jx step create helmfile 
helmfile destroy
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
  </channel>
</rss>
