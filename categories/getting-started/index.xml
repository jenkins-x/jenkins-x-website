<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins X – getting started</title>
    <link>/categories/getting-started/</link>
    <description>Recent content in getting started on Jenkins X</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 03 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="/categories/getting-started/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Multiple Clusters</title>
      <link>/docs/reference/multi-cluster/</link>
      <pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/docs/reference/multi-cluster/</guid>
      <description>
        
        
        

&lt;p&gt;A common requirement for a production setup is to isolate your Development, Staging and Production environments onto separate kubernetes clusters and to isolate the clusters from each other in separate cloud accounts or VPNs etc.&lt;/p&gt;

&lt;p&gt;You can do this by installing the &lt;code&gt;Environment Controller&lt;/code&gt; chart into your Staging or Production cluster.&lt;/p&gt;

&lt;h2 id=&#34;goal&#34;&gt;Goal&lt;/h2&gt;

&lt;p&gt;Our assumption with the Environment Controller is that we need something that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;runs inside your Staging or Production cluster to avoid having to expose write/admin access to Staging/Production outside of your cluster&lt;/li&gt;
&lt;li&gt;has a small with minimal RBAC footprint so it can be installed in any namespace in any Staging/Production cluster which are usually really locked down for security&lt;/li&gt;
&lt;li&gt;makes few assumptions about the cluster (e.g. does not depend on a particular Ingress controller)&lt;/li&gt;
&lt;li&gt;does not require access to the development cluster or anything else in Jenkins X other than the environments git repository and a docker + chart repository&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;creating-your-dev-cluster&#34;&gt;Creating your Dev cluster&lt;/h2&gt;

&lt;p&gt;If you are creating a new installation then when you use &lt;a href=&#34;/commands/jx_create_cluster&#34;&gt;jx create cluster&lt;/a&gt; or &lt;a href=&#34;/commands/jx_install&#34;&gt;jx install&lt;/a&gt; then please specify &lt;code&gt;--remote-environments&lt;/code&gt; to indicate that &lt;code&gt;Staging/Production&lt;/code&gt; environments will be remote from the development cluster.&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx create cluster gke --remote-environments --tekton
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When creating your Environments via &lt;a href=&#34;/commands/jx_create_environment&#34;&gt;jx create environment&lt;/a&gt; you can also specify the environment is remote via the &lt;code&gt;--remote&lt;/code&gt; or answering &lt;code&gt;Y&lt;/code&gt; to the question when prompted.&lt;/p&gt;

&lt;p&gt;What this means is that if an environment is remote to the development cluster then we don&amp;rsquo;t register the release pipeline
of the environment in the Dev cluster; we leave that to the Environment Controller to perform running inside the remote cluster.&lt;/p&gt;

&lt;h2 id=&#34;configure-an-existing-dev-cluster&#34;&gt;Configure an existing Dev cluster&lt;/h2&gt;

&lt;p&gt;If you already have a Dev cluster that was setup with &lt;code&gt;Staging&lt;/code&gt; and &lt;code&gt;Production&lt;/code&gt; namespaces inside your Dev cluster then please do the following:&lt;/p&gt;

&lt;p&gt;Edit the environments to mark them as remote via &lt;a href=&#34;/commands/jx_edit_environment&#34;&gt;jx edit environment&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx edit env staging --remote 
jx edit env production --remote 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need to manually disable the release pipeline in the Dev cluster.&lt;/p&gt;

&lt;p&gt;e.g. by removing the &lt;code&gt;postsubmit&lt;/code&gt; setting in your Prow configuration if you are using &lt;a href=&#34;/docs/concepts/jenkins-x-pipelines/&#34;&gt;serverless Jenkins X Pipelines and tekton&lt;/a&gt; - or comment out the &lt;code&gt;jx step helm apply&lt;/code&gt; command in your &lt;code&gt;Jenkinsfile&lt;/code&gt; if using static jenkins server&lt;/p&gt;

&lt;h2 id=&#34;installing-environment-controller&#34;&gt;Installing Environment Controller&lt;/h2&gt;

&lt;p&gt;First you need to connect to your remote kubernetes cluster for &lt;code&gt;Staging&lt;/code&gt; or &lt;code&gt;Production&lt;/code&gt; using your managed kubernetes provider&amp;rsquo;s tooling.&lt;/p&gt;

&lt;p&gt;You also need to have RBAC karma to be able to &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping&#34; target=&#34;_blank&#34;&gt;escalate roles&lt;/a&gt; for &lt;code&gt;Role&lt;/code&gt; and/or &lt;code&gt;ClusterRole&lt;/code&gt; permissions.&lt;/p&gt;

&lt;p&gt;Then to install the Environment Controller use &lt;a href=&#34;/commands/jx_create_addon_environment/&#34;&gt;jx create addon envctl&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You need to specify the environments git repository and docker registry host and on GCP the project ID:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx create addon envctl -s https://github.com/myorg/env-production.git --project-id myproject --docker-registry gcr.io --cluster-rbac true --user mygituser --token mygittoken
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The installer needs a user + API token for the git repository which it will prompt you for the known values from your &lt;code&gt;~/.jx/gitAuth.yaml&lt;/code&gt; file so if you already installed Jenkins X it should be able to default those values for you.&lt;/p&gt;

&lt;p&gt;If you prefer you can install the helm chart &lt;code&gt;jenkins-x/environment-controller&lt;/code&gt; directly with helm by specifying the &lt;a href=&#34;https://github.com/jenkins-x-charts/environment-controller/blob/master/environment-controller/values.yaml#L3-L19&#34; target=&#34;_blank&#34;&gt;required values from the values.yaml file&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;installing-ingress-controller&#34;&gt;Installing Ingress Controller&lt;/h2&gt;

&lt;p&gt;If you don&amp;rsquo;t already have any kind of Ingress Controller in your remote &lt;code&gt;Staging&lt;/code&gt; / &lt;code&gt;Production&lt;/code&gt; cluster then it is recommend - particularly if you want to try out our &lt;a href=&#34;/docs/getting-started/first-project/create-quickstart/&#34;&gt;quickstarts&lt;/a&gt; which depend on Ingress to be able to be used from a web browser.&lt;/p&gt;

&lt;p&gt;To install the default ingress controller into a remote cluster (which doesn&amp;rsquo;t have Jenkins X installed) you can use the command &lt;a href=&#34;/commands/jx_create_addon_ingress/&#34;&gt;jx create addon ingctl&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx create addon ingctl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will setup the Ingress Controller; find its external domain and then setup a Pull Request on the environments git repository so that future promotions in the environment will use the correct &lt;code&gt;domain&lt;/code&gt; value on the generated &lt;code&gt;Ingress&lt;/code&gt; resources.&lt;/p&gt;

&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;

&lt;p&gt;On startup the Environment Controller registers itself into the github repository as a webhook endpoint using its LoadBalancer service IP address. If you are using a custom ingress/DNS endpoint you can override this via the &lt;code&gt;webhookUrl&lt;/code&gt; chart value or &lt;a href=&#34;/commands/jx_create_addon_environment/&#34;&gt;&amp;ndash;webhook-url CLI option&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Whenever there is a push to the &lt;code&gt;master&lt;/code&gt; branch (PRs and feature branches are handled by your Development cluster) the Environment Controller triggers a new &lt;a href=&#34;/docs/concepts/jenkins-x-pipelines/&#34;&gt;Jenkins X Pipeline&lt;/a&gt; for the Promotion. All other push events on other branches are ignored (as they are processed by the Development cluster).&lt;/p&gt;

&lt;p&gt;Then the tekton controller turns this set of Pipeline resources is turned into one or more Pods which run the pipeline. By default promotion pipelines just use a single pod - but you can &lt;a href=&#34;/docs/concepts/jenkins-x-pipelines/#customising-the-pipelines&#34;&gt;customise your deployment pipeline&lt;/a&gt; which may use sequential/parallel tasks which result in multiple pods.&lt;/p&gt;

&lt;p&gt;Because Environment Controller reacts purely to merges to the environment git repository and we are using canonical git source code; it works with both Static Jenkins Servers and &lt;a href=&#34;/docs/concepts/jenkins-x-pipelines/&#34;&gt;serverless Jenkins X Pipelines and tekton&lt;/a&gt; in the Development cluster.&lt;/p&gt;

&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;

&lt;p&gt;There was a demo of using environment controller in the &lt;a href=&#34;/community/april-18/&#34;&gt;April 19, 2019 Office Hours&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;known-limitations&#34;&gt;Known limitations&lt;/h2&gt;

&lt;p&gt;The following things are not yet automatically configured for you but we hope to automate them soon:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;currently you have to manually add the &lt;code&gt;CHART_REPOSITORY&lt;/code&gt; environment variable into the &lt;code&gt;jenkins-x.yml&lt;/code&gt; file in your environment git repository. e.g. a &lt;code&gt;jenkins-x.yml&lt;/code&gt; file like this will do the trick - using the real URL to your chartmuseum (use &lt;code&gt;jx open&lt;/code&gt; in your development cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;pipelineConfig:
env:
- name: CHART_REPOSITORY
value: http://chartmuseum.jx.1.2.3.4.nip.io
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can do the above via the &lt;a href=&#34;/commands/jx_create_variable/&#34;&gt;jx create var -n CHART_REPOSITORY&lt;/a&gt; command if you are inside a clone of the staging/production git repository - then git commit + merge the change.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Configuration</title>
      <link>/docs/managing-jx/old/config/</link>
      <pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/docs/managing-jx/old/config/</guid>
      <description>
        
        
        

&lt;p&gt;Jenkins X should work out of the box with smart defaults for your cloud provider. e.g. Jenkins X automatically uses ECR if you are using AWS or EKS.&lt;/p&gt;

&lt;p&gt;However you can configure values in the underlying helm charts used by Jenkins X.&lt;/p&gt;

&lt;p&gt;To do this you need to create a &lt;code&gt;myvalues.yaml&lt;/code&gt; file in the current directory you are in when you run either &lt;a href=&#34;/commands/jx_create_cluster&#34;&gt;jx create cluster&lt;/a&gt; or &lt;a href=&#34;/commands/jx_install&#34;&gt;jx install&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Then this YAML file can be used to override any of the underlying &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform/blob/master/jenkins-x-platform/values.yaml&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;values.yaml&lt;/code&gt;&lt;/a&gt; in any of the &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform/blob/master/jenkins-x-platform/requirements.yaml&#34; target=&#34;_blank&#34;&gt;charts&lt;/a&gt; in Jenkins X.&lt;/p&gt;

&lt;h2 id=&#34;making-changes-after-the-install&#34;&gt;Making changes after the install&lt;/h2&gt;

&lt;p&gt;Once you have installed you can make more changes via &lt;a href=&#34;/commands/jx_upgrade_platform/&#34;&gt;jx upgrade platform&lt;/a&gt; which will reuse your &lt;code&gt;myvalues.yaml&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;Or if you use &lt;a href=&#34;/docs/managing-jx/common-tasks/manage-via-gitops/&#34;&gt;GitOps management&lt;/a&gt; you can just create a Pull Request on your Development environment git repository.&lt;/p&gt;

&lt;h2 id=&#34;nexus&#34;&gt;Nexus&lt;/h2&gt;

&lt;p&gt;e.g. if you wish to disable Nexus being installed and instead service link to a separate nexus at a different host name you can use this &lt;code&gt;myvalues.yaml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;nexus:
  enabled: false
nexusServiceLink:
  enabled: true
  externalName: &amp;quot;nexus.jx.svc.cluster.local&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;chartmuseum&#34;&gt;ChartMuseum&lt;/h2&gt;

&lt;p&gt;To disable and service link chart museum add:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;chartmuseum:
  enabled: false
chartmuseumServiceLink:
  enabled: true
  externalName: &amp;quot;jenkins-x-chartmuseum.jx.svc.cluster.local&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jenkins-image&#34;&gt;Jenkins Image&lt;/h2&gt;

&lt;p&gt;We ship with a default Jenkins docker image &lt;a href=&#34;https://hub.docker.com/r/jenkinsxio/jenkinsx/&#34; target=&#34;_blank&#34;&gt;jenkinsxio/jenkinsx&lt;/a&gt; with Jenkins X which has all of our required plugins inside.&lt;/p&gt;

&lt;p&gt;If you wish to add your own plugins you can create your own &lt;code&gt;Dockerfile&lt;/code&gt; and image using our base image like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Dockerfile for adding plugins to Jenkins X 
FROM jenkinsxio/jenkinsx:latest

COPY plugins.txt /usr/share/jenkins/ref/openshift-plugins.txt
RUN /usr/local/bin/install-plugins.sh &amp;lt; /usr/share/jenkins/ref/openshift-plugins.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add your custom plugins to &lt;code&gt;plugins.txt&lt;/code&gt; locally of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myplugin:1.2.3
anotherplugin:4.5.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have built and released your image via CI/CD you can then use it in your Jenkins X installation.&lt;/p&gt;

&lt;p&gt;To configure Jenkins X to use your custom image you can specify your own Jenkins image via a &lt;code&gt;myvalues.yaml&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;jenkins:
  Master:
    Image: &amp;quot;acme/my-jenkinsx&amp;quot;
    ImageTag: &amp;quot;1.2.3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is an example OSS project &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-openshift-image&#34; target=&#34;_blank&#34;&gt;jenkins-x/jenkins-x-openshift-image&lt;/a&gt; you could use as a template which creates a new Jenkins image to add OpenShift specific plugins and configuration for using Jenkins X on OpenShift.&lt;/p&gt;

&lt;h2 id=&#34;docker-registry&#34;&gt;Docker Registry&lt;/h2&gt;

&lt;p&gt;We try and use the best defaults for each platform for the Docker Registry; e.g. using ECR on AWS.&lt;/p&gt;

&lt;p&gt;However you can also specify this via the &lt;code&gt;--docker-registry&lt;/code&gt; option when running  &lt;a href=&#34;/commands/jx_create_cluster&#34;&gt;jx create cluster&lt;/a&gt; or &lt;a href=&#34;/commands/jx_install&#34;&gt;jx install&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx create cluster gke --docker-registry eu.gcr.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though if you use a different Docker Registry you will probably need to &lt;a href=&#34;/docs/managing-jx/common-tasks/docker-registry/#update-the-config-json-secret&#34;&gt;also modify the secret for connecting to docker&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Create custom Builder</title>
      <link>/docs/managing-jx/common-tasks/create-custom-builder/</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>/docs/managing-jx/common-tasks/create-custom-builder/</guid>
      <description>
        
        
        

&lt;p&gt;In Jenkins X, it is possible to create your custom Builders (aka &lt;a href=&#34;https://github.com/jenkinsci/kubernetes-plugin&#34; target=&#34;_blank&#34;&gt;POD templates&lt;/a&gt;) or overwrite existing onces. You just need to base your Docker
image on this &lt;a href=&#34;https://github.com/jenkins-x/builder-base/blob/master/Dockerfile.common&#34; target=&#34;_blank&#34;&gt;builder-base&lt;/a&gt; image or on its &lt;a href=&#34;https://github.com/jenkins-x/builder-base/blob/master/Dockerfile.slim&#34; target=&#34;_blank&#34;&gt;slim&lt;/a&gt; version.
These images contain a number of pre-installed tools which get constantly updated and published to &lt;a href=&#34;https://hub.docker.com/r/jenkinsxio/builder-base/&#34; target=&#34;_blank&#34;&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;create-a-custom-builder-from-scratch&#34;&gt;Create a custom Builder from scratch&lt;/h2&gt;

&lt;h3 id=&#34;builder-image&#34;&gt;Builder image&lt;/h3&gt;

&lt;p&gt;First you need to create a docker image for your builder. For instance a starting &lt;code&gt;Dockerfile&lt;/code&gt; can look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM jenkinsxio/builder-base:latest

# Install your tools and libraries
RUN yum install -y gcc openssl-devel

CMD [&amp;quot;gcc&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can build the image and publish it to your registry:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export BUILDER_IMAGE=&amp;lt;YOUR_REGISTRY&amp;gt;/&amp;lt;YOUR_BUILDER_IMAGE&amp;gt;:&amp;lt;VERSION&amp;gt; 
docker build -t ${BUILDER_IMAGE} .
docker push ${BUILDER_IMAGE} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do not worry, you do not have to run manually these steps every time when a new image needs to be built.
Jenkins X can manage this for you. You just need to push your &lt;code&gt;Dockerfile&lt;/code&gt; in a repository similar with &lt;a href=&#34;https://github.com/jenkins-x/builder-go&#34; target=&#34;_blank&#34;&gt;this
&lt;/a&gt; one. Adjust the &lt;code&gt;Jenkinsfile&lt;/code&gt; according with your organization and
application name, and then import the repository into your Jenkins X platform with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx import --url &amp;lt;REPOSITORY_URL&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From now on, every time you push a change, Jenkins X will build and publish automatically the image.&lt;/p&gt;

&lt;h3 id=&#34;install-the-builder&#34;&gt;Install the Builder&lt;/h3&gt;

&lt;p&gt;You can now install your builder either when you install Jenkins X or upgrade it.&lt;/p&gt;

&lt;p&gt;Create a &lt;code&gt;myvalues.yaml&lt;/code&gt; file in your &lt;code&gt;~/.jx/&lt;/code&gt; folder with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;jenkins:
  Agent:
    PodTemplates:
      MyBuilder:
        Name: mybuilder
        Label: jenkins-mybuilder
        volumes:
        - type: Secret
          secretName: jenkins-docker-cfg
          mountPath: /home/jenkins/.docker
        EnvVars:
          JENKINS_URL: http://jenkins:8080
          GIT_COMMITTER_EMAIL: jenkins-x@googlegroups.com
          GIT_AUTHOR_EMAIL: jenkins-x@googlegroups.com
          GIT_AUTHOR_NAME: jenkins-x-bot
          GIT_COMMITTER_NAME: jenkins-x-bot
          XDG_CONFIG_HOME: /home/jenkins
          DOCKER_CONFIG: /home/jenkins/.docker/
        ServiceAccount: jenkins
        Containers:
          Jnlp:
            Image: jenkinsci/jnlp-slave:3.14-1
            RequestCpu: &amp;quot;100m&amp;quot;
            RequestMemory: &amp;quot;128Mi&amp;quot;
            Args: &#39;${computer.jnlpmac} ${computer.name}&#39;
          Dlang:
            Image: &amp;lt;YOUR_BUILDER_IMAGE&amp;gt; 
            Privileged: true
            RequestCpu: &amp;quot;400m&amp;quot;
            RequestMemory: &amp;quot;512Mi&amp;quot;
            LimitCpu: &amp;quot;1&amp;quot;
            LimitMemory: &amp;quot;1024Mi&amp;quot;
            Command: &amp;quot;/bin/sh -c&amp;quot;
            Args: &amp;quot;cat&amp;quot;
            Tty: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Replace the builder name and image accordingly.&lt;/p&gt;

&lt;p&gt;You can proceed now with the Jenkins X installation, the builder will be automatically added to the platform.&lt;/p&gt;

&lt;h3 id=&#34;use-the-builder&#34;&gt;Use the Builder&lt;/h3&gt;

&lt;p&gt;Now that your builder was installed in Jenkins, you can easily reference it in a &lt;code&gt;Jenkinsfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Groovy&#34;&gt;pipeline {
    agent {
        label &amp;quot;jenkins-mybuilder&amp;quot;
    }
    stages {
      stage(&#39;Build&#39;) {
        when {
          branch &#39;master&#39;
        }
        steps {
          container(&#39;mybuilder&#39;) {
              // your steps
          }
        }
      }
    }
    post {
        always {
            cleanWs()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;overwrite-existing-builders&#34;&gt;Overwrite existing Builders&lt;/h2&gt;

&lt;p&gt;Jenkins X comes with a number of &lt;a href=&#34;https://raw.githubusercontent.com/jenkins-x/jenkins-x-platform/master/values.yaml&#34; target=&#34;_blank&#34;&gt;pre-installed builders&lt;/a&gt;
which you can overwrite if required during installation or upgrade.&lt;/p&gt;

&lt;p&gt;You just need to build your custom image either based on &lt;a href=&#34;https://github.com/jenkins-x/builder-base/blob/master/Dockerfile.common&#34; target=&#34;_blank&#34;&gt;builder-base&lt;/a&gt;
image or the &lt;a href=&#34;https://hub.docker.com/u/jenkinsxio/&#34; target=&#34;_blank&#34;&gt;builder image&lt;/a&gt; you want to overwrite. See more details above.&lt;/p&gt;

&lt;p&gt;Then you can create a &lt;code&gt;myvalues.yaml&lt;/code&gt; file in your &lt;code&gt;~/.jx/&lt;/code&gt; folder with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jenkins:
  Agent:
    PodTemplates:
      Maven:
        Containers:
          Maven:
            Image: &amp;lt;YOUR_REGISTRY&amp;gt;/&amp;lt;YOUR_MAVEN_BUILDER_IMAGE&amp;gt;:&amp;lt;VERSION&amp;gt;
      Nodejs:
        Containers:
          Nodejs:
            Image: &amp;lt;YOUR_REGISTRY&amp;gt;/&amp;lt;YOUR_NODEJS_BUILDER_IMAGE&amp;gt;:&amp;lt;VERSION&amp;gt;
      Go:
        Containers:
          Go:
            Image: &amp;lt;YOUR_REGISTRY&amp;gt;/&amp;lt;YOUR_GO_BUILDER_IMAGE&amp;gt;:&amp;lt;VERSION&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can proceed now with the Jenkins X installation, the builder will  be added automatically to the platform.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Create EKS cluster with Terraform</title>
      <link>/docs/getting-started/setup/create-cluster/amazon/terraform/</link>
      <pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/docs/getting-started/setup/create-cluster/amazon/terraform/</guid>
      <description>
        
        
        &lt;p&gt;This is a short guide to setup EKS on AWS and the required resources for Jenkins X&amp;rsquo;s setup of Vault
using Terraform. It assumes access to AWS is configured and familiarity with AWS, kubectl and Terraform.&lt;/p&gt;

&lt;p&gt;This snippet of Terraform code sets EKS and up needed resources on AWS. It outputs the parameters
you then need to add to append to &lt;code&gt;jx install&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tf&#34;&gt;variable &amp;quot;region&amp;quot; {
}

variable &amp;quot;subnets&amp;quot; {
    type = &amp;quot;list&amp;quot;
}

variable &amp;quot;vpc_id&amp;quot; {
}

variable &amp;quot;key_name&amp;quot; {
    description = &amp;quot;SSH key name for worker nodes&amp;quot;
}

variable &amp;quot;bucket_domain&amp;quot; {
    description = &amp;quot;Suffix for S3 bucket used for vault unseal operation&amp;quot;
}

provider &amp;quot;aws&amp;quot; {
    region  = &amp;quot;${var.region}&amp;quot;
}

module &amp;quot;eks&amp;quot; {
    source       = &amp;quot;terraform-aws-modules/eks/aws&amp;quot;
    cluster_name = &amp;quot;${var.region}&amp;quot;
    subnets      = &amp;quot;${var.subnets}&amp;quot;
    vpc_id       = &amp;quot;${var.vpc_id}&amp;quot;
    worker_groups = [
        {
            autoscaling_enabled   = true
            asg_min_size          = 3
            asg_desired_capacity  = 3
            instance_type         = &amp;quot;t3.large&amp;quot;
            asg_max_size          = 20
            key_name              = &amp;quot;${var.key_name}&amp;quot;
        }
    ]
    version = &amp;quot;5.0.0&amp;quot;
}

# Needed for cluster-autoscaler
resource &amp;quot;aws_iam_role_policy_attachment&amp;quot; &amp;quot;workers_AmazonEC2ContainerRegistryPowerUser&amp;quot; {
  policy_arn = &amp;quot;arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryPowerUser&amp;quot;
  role       = &amp;quot;${module.eks.worker_iam_role_name}&amp;quot;
}

# Create S3 bucket for KMS
resource &amp;quot;aws_s3_bucket&amp;quot; &amp;quot;vault-unseal&amp;quot; {
    bucket = &amp;quot;vault-unseal.${var.region}.${var.bucket_domain}&amp;quot;
    acl    = &amp;quot;private&amp;quot;

    versioning {
        enabled = false
    }
}

# Create KMS key
resource &amp;quot;aws_kms_key&amp;quot; &amp;quot;bank_vault&amp;quot; {
    description = &amp;quot;KMS Key for bank vault unseal&amp;quot;
}

# Create DynamoDB table
resource &amp;quot;aws_dynamodb_table&amp;quot; &amp;quot;vault-data&amp;quot; {
    name           = &amp;quot;vault-data&amp;quot;
    read_capacity  = 2
    write_capacity = 2
    hash_key       = &amp;quot;Path&amp;quot;
    range_key      = &amp;quot;Key&amp;quot;
    attribute {
        name = &amp;quot;Path&amp;quot;
        type = &amp;quot;S&amp;quot;
    }

    attribute {
        name = &amp;quot;Key&amp;quot;
        type = &amp;quot;S&amp;quot;
    }
}

# Create service account for vault. Should the policy
resource &amp;quot;aws_iam_user&amp;quot; &amp;quot;vault&amp;quot; {
  name = &amp;quot;vault_${var.region}&amp;quot;
}

data &amp;quot;aws_iam_policy_document&amp;quot; &amp;quot;vault&amp;quot; {
    statement {
        sid = &amp;quot;DynamoDB&amp;quot;
        effect = &amp;quot;Allow&amp;quot;
        actions = [
            &amp;quot;dynamodb:DescribeLimits&amp;quot;,
            &amp;quot;dynamodb:DescribeTimeToLive&amp;quot;,
            &amp;quot;dynamodb:ListTagsOfResource&amp;quot;,
            &amp;quot;dynamodb:DescribeReservedCapacityOfferings&amp;quot;,
            &amp;quot;dynamodb:DescribeReservedCapacity&amp;quot;,
            &amp;quot;dynamodb:ListTables&amp;quot;,
            &amp;quot;dynamodb:BatchGetItem&amp;quot;,
            &amp;quot;dynamodb:BatchWriteItem&amp;quot;,
            &amp;quot;dynamodb:CreateTable&amp;quot;,
            &amp;quot;dynamodb:DeleteItem&amp;quot;,
            &amp;quot;dynamodb:GetItem&amp;quot;,
            &amp;quot;dynamodb:GetRecords&amp;quot;,
            &amp;quot;dynamodb:PutItem&amp;quot;,
            &amp;quot;dynamodb:Query&amp;quot;,
            &amp;quot;dynamodb:UpdateItem&amp;quot;,
            &amp;quot;dynamodb:Scan&amp;quot;,
            &amp;quot;dynamodb:DescribeTable&amp;quot;
        ]
        resources = [&amp;quot;${aws_dynamodb_table.vault-data.arn}&amp;quot;]
    }
    statement {
        sid = &amp;quot;S3&amp;quot;
        effect = &amp;quot;Allow&amp;quot;
        actions = [
                &amp;quot;s3:PutObject&amp;quot;,
                &amp;quot;s3:GetObject&amp;quot;
        ]
        resources = [&amp;quot;${aws_s3_bucket.vault-unseal.arn}/*&amp;quot;]
    }
    statement {
        sid = &amp;quot;S3List&amp;quot;
        effect = &amp;quot;Allow&amp;quot;
        actions = [
            &amp;quot;s3:ListBucket&amp;quot;
        ]
        resources = [&amp;quot;${aws_s3_bucket.vault-unseal.arn}&amp;quot;]
    }
    statement {
        sid = &amp;quot;KMS&amp;quot;
        effect = &amp;quot;Allow&amp;quot;
        actions = [
            &amp;quot;kms:Encrypt&amp;quot;,
            &amp;quot;kms:Decrypt&amp;quot;,
            &amp;quot;kms:DescribeKey&amp;quot;
        ]
        resources = [&amp;quot;${aws_kms_key.bank_vault.arn}&amp;quot;]
    }
}

resource &amp;quot;aws_iam_user_policy&amp;quot; &amp;quot;vault&amp;quot; {
    name = &amp;quot;vault_${var.region}&amp;quot;
    user = &amp;quot;${aws_iam_user.vault.name}&amp;quot;

    policy = &amp;quot;${data.aws_iam_policy_document.vault.json}&amp;quot;
}

resource &amp;quot;aws_iam_access_key&amp;quot; &amp;quot;vault&amp;quot; {
    user = &amp;quot;${aws_iam_user.vault.name}&amp;quot;
}

# Output KMS key id, S3 bucket name and secret name in the form of jx install options
output &amp;quot;jx_params&amp;quot; {
    value = &amp;quot;--provider=eks --gitops --no-tiller --vault --aws-dynamodb-region=${var.region} --aws-dynamodb-table=${aws_dynamodb_table.vault-data.name} --aws-kms-region=${var.region} --aws-kms-key-id=${aws_kms_key.bank_vault.key_id} --aws-s3-region=${var.region}  --aws-s3-bucket=${aws_s3_bucket.vault-unseal.id} --aws-access-key-id=${aws_iam_access_key.vault.id} --aws-secret-access-key=${aws_iam_access_key.vault.secret}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save as &lt;code&gt;eks.tf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The module terraform-aws-modules/eks/aws will also store a kubeconfig file as &lt;code&gt;config&lt;/code&gt;. This can be
copied to or merged with your &lt;code&gt;~/.kube/config&lt;/code&gt;. Then &lt;code&gt;jx install&lt;/code&gt; can be run with the parameters
output by the Terraform config above.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Install on Kubernetes</title>
      <link>/docs/managing-jx/old/install-on-cluster/</link>
      <pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/docs/managing-jx/old/install-on-cluster/</guid>
      <description>
        
        
        

&lt;p&gt;Jenkins X can be installed on 1.8 or later of Kubernetes. The requirements are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RBAC is enabled&lt;/li&gt;
&lt;li&gt;Your Kubernetes cluster has a &lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/storage-classes/&#34; target=&#34;_blank&#34;&gt;default storage class&lt;/a&gt; setup so that &lt;code&gt;Persistent Volume Claims&lt;/code&gt; can be bound to &lt;code&gt;Persistent Volumes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If not using the &lt;code&gt;aws&lt;/code&gt; or &lt;code&gt;eks&lt;/code&gt; providers, then we need to make sure that insecure Docker registries are enabled. This is so that pipelines can use a Docker registry running inside the Kubernetes cluster (which typically is not public, so no https support). You can modify your pipelines to use other registries later.&lt;/li&gt;
&lt;li&gt;A cluster with at least 4 vCPUs in addition to the master node (e.g. 2 m4.large worker nodes + 1 m4.large master node)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;validating-cluster-conformance&#34;&gt;Validating cluster conformance&lt;/h3&gt;

&lt;p&gt;You can validate that your cluster is compliant with Jenkins X by executing the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx compliance run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will run the Kubernetes conformance tests provided by &lt;a href=&#34;https://github.com/heptio/sonobuoy&#34; target=&#34;_blank&#34;&gt;sonobuoy&lt;/a&gt;. Typically, the execution takes up to an hour.
You can check the status at any time with this command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx compliance status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the compliance tests are completed, you can see the results with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx compliance results
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ideally, you should not see any failed tests in the output.&lt;/p&gt;

&lt;p&gt;All the resources created by the conformance tests can be cleaned up with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx compliance delete
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-aws&#34;&gt;Using AWS&lt;/h2&gt;

&lt;p&gt;If you are using AWS, be sure to check out the detailed blog on &lt;a href=&#34;https://aws.amazon.com/blogs/opensource/continuous-delivery-eks-jenkins-x/&#34; target=&#34;_blank&#34;&gt;Continuous Delivery with Amazon EKS and Jenkins X&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/hekonsek&#34; target=&#34;_blank&#34;&gt;Henryk Konsek&lt;/a&gt; which goes into lots of detail on how to setup AWS + EKS with Jenkins X.&lt;/p&gt;

&lt;p&gt;If you want to go further with infrastructure as code you can follow this
&lt;a href=&#34;/docs/managing-jx/common-tasks/aws-terraform-install-gitops/&#34;&gt;guide&lt;/a&gt; about setting up an EKS cluster and other
requirements in AWS with Terraform and then installing Jenkins X on it using GitOps for the
installation.&lt;/p&gt;

&lt;h3 id=&#34;ingress-on-aws&#34;&gt;Ingress on AWS&lt;/h3&gt;

&lt;p&gt;On AWS, the ideal setup is to use a Route 53 DNS wildcard CNAME to point &lt;code&gt;*.somedomain&lt;/code&gt; at your ELB or NLB host name. Then, when prompted by &lt;code&gt;jx&lt;/code&gt;, you install &lt;code&gt;somedomain&lt;/code&gt; (where &lt;code&gt;somedomain&lt;/code&gt; is an actual DNS domain/subdomain you own).&lt;/p&gt;

&lt;p&gt;Then, all the &lt;code&gt;Ingress&lt;/code&gt; resources for any exposed service in any namespace will appear as &lt;code&gt;mysvc.myns.somedomain&lt;/code&gt; - whether for things like Jenkins or Nexus or for your own microservices or Preview Environments.&lt;/p&gt;

&lt;p&gt;Using wildcard DNS pointing to your ELB/NLB also means you&amp;rsquo;ll be able to use all the availability zones on AWS.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;jx&lt;/code&gt; command will ask you if you want to automate the setup fo the Route 53 wildcard CNAME. If you want to do it yourself, you need to point to the ELB host name defined via:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl get service -n kube-system jxing-nginx-ingress-controller  -oyaml | grep hostname
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;avoiding-dns&#34;&gt;Avoiding DNS&lt;/h4&gt;

&lt;p&gt;If you want to kick the tires of Jenkins X without going to the trouble of getting a DNS domain name to use and setting up wildcard DNS, you can instead use an NLB and use one of the IP addresses of one of the availability zones as your domain via &lt;code&gt;$IP.ip&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is not really intended for real production installations. However, it can be a quick way to get started trying out Jenkins X.&lt;/p&gt;

&lt;p&gt;When using &lt;code&gt;jx install --provider=(aws|eks)&lt;/code&gt;, you are prompted if you want to use DNS and optionally setup a wildcard DNS CNAME record on Route 53. If not, we assume you&amp;rsquo;re going to avoid DNS to kick the tires on a single availability zone IP address by resolving the NLB host name to one of the availability zone IP addresses.&lt;/p&gt;

&lt;h3 id=&#34;getting-registries-to-work-on-aws-with-cluster-set-up-with-kops&#34;&gt;Getting registries to work on AWS with cluster set up with kops&lt;/h3&gt;

&lt;p&gt;The default on AWS is to use ECR as the Docker container registry. For this to work, the nodes need permission to upload images to ECR. If you instead want to use the embedded Docker registry of Jenkins X inside your Kubernetes cluster, you will need to enable insecure Docker registries.&lt;/p&gt;

&lt;p&gt;Note that you may want to use the &lt;a href=&#34;/docs/getting-started/setup/create-cluster/#using-amazon-aws&#34;&gt;jx create cluster aws&lt;/a&gt; command which automates all of this for you!&lt;/p&gt;

&lt;h4 id=&#34;give-nodes-permission-to-use-ecr&#34;&gt;Give nodes permission to use ECR&lt;/h4&gt;

&lt;p&gt;Do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kops edit cluster
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then make sure the YAML has this &lt;code&gt;additionalPolicies&lt;/code&gt; entry inside the &lt;code&gt;spec&lt;/code&gt; section:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;...
spec:
  additionalPolicies:
    node: |
      [
        {
        &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;,
        &amp;quot;Action&amp;quot;: [&amp;quot;ecr:InitiateLayerUpload&amp;quot;, &amp;quot;ecr:UploadLayerPart&amp;quot;,&amp;quot;ecr:CompleteLayerUpload&amp;quot;,&amp;quot;ecr:PutImage&amp;quot;],
        &amp;quot;Resource&amp;quot;: [&amp;quot;*&amp;quot;]
        }
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now to make this change active on your cluster type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kops update cluster --yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should now be good to go!&lt;/p&gt;

&lt;h4 id=&#34;enabling-insecure-registries-on-kops&#34;&gt;Enabling insecure registries on kops&lt;/h4&gt;

&lt;p&gt;Do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kops edit cluster
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then make sure the YAML has this &lt;code&gt;docker&lt;/code&gt; entry inside the &lt;code&gt;spec&lt;/code&gt; section:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;...
spec:
  docker:
    insecureRegistry: 100.64.0.0/10
    logDriver: &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That IP range, &lt;code&gt;100.64.0.0/10&lt;/code&gt;, works on AWS, but you may need to change it on other Kubernetes clusters. It depends on the IP range of Kubernetes services.&lt;/p&gt;

&lt;p&gt;Then save the changes. You can verify your changes via:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kops get cluster -oyaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and looking for the &lt;code&gt;insecureRegistry&lt;/code&gt; section.&lt;/p&gt;

&lt;p&gt;Now to make this change active on your cluster type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kops update cluster --yes
kops rolling-update cluster --yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should now be good to go!&lt;/p&gt;

&lt;h2 id=&#34;installing-jenkins-x-on-a-cloud&#34;&gt;Installing Jenkins X on a cloud&lt;/h2&gt;

&lt;p&gt;To install Jenkins X on an existing Kubernetes cluster, you can then use the &lt;a href=&#34;/commands/jx_install&#34;&gt;jx install&lt;/a&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you know the provider, you can specify the provider on the command line. e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx install --provider=aws
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: if you wish to use a different Git provider than GitHub for your environments, see &lt;a href=&#34;/docs/managing-jx/common-tasks/git/#using-a-different-git-provider-for-environments&#34;&gt;how to use a different Git provider&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;installing-jenkins-x-on-premises&#34;&gt;Installing Jenkins X on premises&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Prerequisits&lt;/strong&gt;
- Kubernetes &amp;gt; 1.8
- RBAC enabled
- A default cluster &lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/&#34; target=&#34;_blank&#34;&gt;dynamic storage class&lt;/a&gt; for provisioning persistent volumes.&lt;/p&gt;

&lt;p&gt;When using an on premise Kubernetes cluster, you can use this command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx install --provider=kubernetes --on-premise
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will default the argument for &lt;code&gt;--external-ip&lt;/code&gt; to access services inside your cluster to use the Kubernetes master IP address.&lt;/p&gt;

&lt;p&gt;If you wish to use a different external IP address, you can use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx install --provider=kubernetes --external-ip 1.2.3.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise, the &lt;code&gt;jx install&lt;/code&gt; will try and wait for the Ingress Controllers &lt;code&gt;Service.Status.LoadBalancer.Ingress&lt;/code&gt; to resolve to an IP address - which can fail on premise.&lt;/p&gt;

&lt;p&gt;If you already have an ingress controller installed, then try:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx install --provider=kubernetes \
--skip-ingress \
--external-ip=10.20.30.40 \
--domain=10.20.30.40.nip.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you do not know the domain or want it extracted from your Ingress deployment, try&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx install --provider=kubernetes --external-ip 10.123.0.17 \
--ingress-service=$(yoursvcname) \
--ingress-deployment=$(yourdeployname) \
--ingress-namespace=kube-system
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want an explanation of what the &lt;a href=&#34;/commands/jx_install&#34;&gt;jx install&lt;/a&gt; command does, you can read &lt;a href=&#34;../install-on-cluster-what-happens&#34;&gt;what happens with the install&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;installing-jenkins-x-on-ibm-cloud-private&#34;&gt;Installing Jenkins X on IBM Cloud Private&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Prerequisites&lt;/strong&gt;
- IBM Cloud Private version 3.1.0 is compatible with Jenkins X version 1.3.572.
- You might have to clean up with the &lt;code&gt;helm delete --purge jenkins-x&lt;/code&gt; or &lt;code&gt;jx uninstall&lt;/code&gt; commands. However, the &lt;code&gt;jx uninstall&lt;/code&gt; command might not correctly pick up Helm releases at the &lt;code&gt;default&lt;/code&gt; namespace if you point to the &lt;code&gt;kube-system&lt;/code&gt; Tiller.&lt;/p&gt;

&lt;p&gt;IBM Cloud Private includes a Docker registry and ingress controller. You can install Jenkins X into IBM Cloud Private with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jx install --provider=icp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The installation process prompts for the master IP address in your Kubernetes cluster. The master IP address is the same address that you used to access the IBM Cloud Private dashboard.&lt;/p&gt;

&lt;p&gt;Create &lt;code&gt;ClusterImagePolicies&lt;/code&gt; on IBM Cloud Private version 3.1.0 and set the following permissions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- name: docker.io/*
- name: gcr.io/*
- name: quay.io/*
- name: k8s.gcr.io/*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Specify the following two &lt;code&gt;jx install&lt;/code&gt; parameters with the command line or when prompted by the IBM Cloud Private provider:
- The &lt;code&gt;domain=&#39;&#39;&lt;/code&gt; parameter is the domain to expose ingress endpoints, for example, &lt;code&gt;jenkinsx.io&lt;/code&gt;.
- The &lt;code&gt;external-ip=&#39;&#39;&lt;/code&gt; parameter is the external IP that is used to access ingress endpoints from outside the Kubernetes cluster and for bare metal on premise clusters.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t specify these parameters, then the &lt;code&gt;jx install --provider=icp&lt;/code&gt; command first prompts you to enter the &lt;code&gt;external-ip&lt;/code&gt; parameter. Next, it prompts you to enter the &lt;code&gt;domain&lt;/code&gt; parameter and offers you the &lt;code&gt;&amp;lt;external-ip&amp;gt;.nip.io&lt;/code&gt; default value. After you enter these values, an ingress endpoint becomes available at &lt;code&gt;http://jenkins.jx.&amp;lt;your cluster IP&amp;gt;.nip.io&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A Tiller is set in the default namespace as part of the Jenkins X installation process. To ensure that all Helm commands point to the correct Tiller, enter the &lt;code&gt;export TILLER_NAMESPACE=default&lt;/code&gt; command when interacting with your Jenkins X installation.&lt;/p&gt;

&lt;p&gt;Create registry secrets and patch the default service account in any of the namespaces that Jenkins X creates. Deployments can then pull images from the IBM Cloud Private registry.&lt;/p&gt;

&lt;p&gt;If you create environments manually, you can specify &lt;code&gt;--pull-secrets &amp;lt;secret name&amp;gt;&lt;/code&gt; with the &lt;code&gt;jx create environment&lt;/code&gt; command. The created service account is automatically configured to use the pull secret that you mention. The pull secret needs to exist in the created namespace.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Manage by GitOps</title>
      <link>/docs/managing-jx/old/manage-via-gitops/</link>
      <pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/docs/managing-jx/old/manage-via-gitops/</guid>
      <description>
        
        
        

&lt;p&gt;We recommend you use GitOps to manage your installation of Jenkins X, to upgrade it, configure it and add or remove extension &lt;a href=&#34;/docs/contributing/addons/&#34;&gt;Apps&lt;/a&gt; so it’s easy to audit who changes what in your installation and to easily revert bad changes.&lt;/p&gt;

&lt;p&gt;Currently this only works on AWS and Google cloud as it requires our vault operator (which needs cloud storage &amp;amp; KMS) to store secrets while all other configuration is stored in the development environment git repository.&lt;/p&gt;

&lt;h2 id=&#34;using-gitops-to-manage-jenkins-x&#34;&gt;Using GitOps to manage Jenkins X&lt;/h2&gt;

&lt;p&gt;If you are creating a cluster or installing on an existing cluster there is a quick and handy way to use GitOps to manage Jenkins X itself - it’s &lt;code&gt;—ng&lt;/code&gt; for the next generation of Jenkins X. We’ll make this feature flags options the default when we release 2.x of Jenkins X later this year.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;—ng&lt;/code&gt; flag is an alias for these flags: &lt;code&gt;—gitops —vault —no-tiller —tekton&lt;/code&gt;. So it also comes with baked in support for &lt;a href=&#34;/docs/concepts/jenkins-x-pipelines/&#34;&gt;Jenkins X Pipelines&lt;/a&gt; - the modern cloud native pipeline engine based on Tekton.&lt;/p&gt;

&lt;p&gt;If you still want to use a Jenkins server as the execution engine for the automated CI/CD pipelines in Jenkins X then you can use &lt;code&gt;—gitops —vault&lt;/code&gt; instead. Though note that even if using &lt;code&gt;—ng&lt;/code&gt; and using &lt;a href=&#34;/docs/concepts/jenkins-x-pipelines/&#34;&gt;Jenkins X Pipelines&lt;/a&gt; powered by tekton - you can still create your own &lt;a href=&#34;/docs/managing-jx/common-tasks/custom-jenkins/&#34;&gt;custom Jenkins servers&lt;/a&gt; to run traditional Jenkins jobs and pipelines!&lt;/p&gt;

&lt;p&gt;Once you have installed Jenkins X using GitOps to manage the dev environment- the install of Jenkins X and it’s additional Apps - you get an extra git repository for Dev, Staging and Production. It also means that if you use an upgrade command like &lt;a href=&#34;/commands/jx_upgrade_platform/&#34;&gt;jx upgrade platform&lt;/a&gt; or add, upgrade or delete Apps via &lt;a href=&#34;/commands/jx_add_app/&#34;&gt;jx add app&lt;/a&gt; then those commands will generate Pull Requests on the dev environment git repository - rather like how promotion works when you release new versions of your microservices.&lt;/p&gt;

&lt;h2 id=&#34;if-things-go-bad&#34;&gt;If things go bad&lt;/h2&gt;

&lt;p&gt;Generally speaking Jenkins X can upgrade itself quite easily when using tekton. However if an upgrade breaks Jenkins X from implementing CI/CD then the GitOps to revert the change won’t work ;)&lt;/p&gt;

&lt;p&gt;if you hit any issues upgrading Jenkins X there is a manual way to apply the contents of the development environment’s git repository&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone $MY_DEV_GIT_CLONE_URL jenkins-x-dev-env
cd jenkins-x-dev-env/env
jx step env apply 
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: What happens during installation</title>
      <link>/docs/managing-jx/old/install-on-cluster-what-happens/</link>
      <pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/docs/managing-jx/old/install-on-cluster-what-happens/</guid>
      <description>
        
        
        

&lt;p&gt;The Jenkins X CLI will do the following when installing the Jenkins X platform:&lt;/p&gt;

&lt;h2 id=&#34;install-client-binaries-to-manage-your-cluster&#34;&gt;Install client binaries to manage your cluster&lt;/h2&gt;



&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;

If you are running on Mac OS X, Jenkins X is using &lt;code&gt;Homebrew&lt;/code&gt; to install the various CLI. It will install it if not present.
&lt;/div&gt;


&lt;h3 id=&#34;install-kubectl&#34;&gt;Install kubectl&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/kubectl/kubectl/&#34; target=&#34;_blank&#34;&gt;kubectl&lt;/a&gt; is the CLI of Kubernetes. It allows you to interact with your Kubernetes cluster via the API server.&lt;/p&gt;

&lt;h3 id=&#34;install-helm&#34;&gt;Install Helm&lt;/h3&gt;

&lt;p&gt;Jenkins X will install the &lt;a href=&#34;https://github.com/kubernetes/helm&#34; target=&#34;_blank&#34;&gt;helm&lt;/a&gt; client - (either  helm &lt;em&gt;2.x&lt;/em&gt; or helm &lt;em&gt;3&lt;/em&gt;), if it does not already exist in your command shell path. Helm is used for packaging applications/resources (called charts) on Kubernetes, and is rapidly becoming the default standard for doing so.&lt;/p&gt;

&lt;h3 id=&#34;install-cloud-provider-cli&#34;&gt;Install cloud provider CLI&lt;/h3&gt;

&lt;p&gt;If you are using a public cloud, there will be an associated CLI for interacting with it. When install is called via the &lt;a href=&#34;/docs/getting-started/setup/create-cluster/&#34;&gt;jx create cluster&lt;/a&gt; command, the associated binary to your cloud provider will also be installed, if not present on your command shell path.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;az&lt;/code&gt; for AKS cluster (Azure)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gcloud&lt;/code&gt; for GKE cluster (Google Cloud)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kops&lt;/code&gt; for AWS cluster (Amazon Web Services)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eksctl&lt;/code&gt; for &lt;a href=&#34;https://aws.amazon.com/eks/&#34; target=&#34;_blank&#34;&gt;AWS EKS&lt;/a&gt; cluster&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oci&lt;/code&gt; for OKS cluster (Oracle Cloud)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want to run Jenkins X locally via minikube or minishift, the following binaries are added:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oc&lt;/code&gt; (OpenShift CLI) and &lt;code&gt;minishift&lt;/code&gt; for a local minishift cluster (OpenShift)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minikube&lt;/code&gt; for a local minikube cluster&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Last but not least, Jenkins X will install the VM driver when required, typically &lt;code&gt;xhyve&lt;/code&gt; for Mac OS X or &lt;code&gt;hyperv&lt;/code&gt; for Windows. Other drivers (VirtualBox, VMWare&amp;hellip;) must be installed manually.&lt;/p&gt;

&lt;h2 id=&#34;create-the-kubernetes-cluster&#34;&gt;Create the Kubernetes cluster&lt;/h2&gt;

&lt;p&gt;The cluster is then created using the cloud provider CLI (for example &lt;code&gt;az aks create&lt;/code&gt; command  for Azure).&lt;/p&gt;

&lt;h2 id=&#34;setup-the-jenkins-x-platform&#34;&gt;Setup the Jenkins X platform&lt;/h2&gt;

&lt;h3 id=&#34;create-the-jenkins-x-namespace&#34;&gt;Create the Jenkins X namespace&lt;/h3&gt;

&lt;p&gt;Then Jenkins X install will create a namespace for the Jenkins X platform where all the Jenkins X infrastructure components will reside. The default is &lt;em&gt;jx&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;install-tiller-optional-only-for-helm-2&#34;&gt;Install Tiller (optional, only for Helm 2)&lt;/h3&gt;

&lt;p&gt;Tiller, the server part of Helm, is then deployed on the &lt;em&gt;kube-system&lt;/em&gt; namespace. &lt;a href=&#34;https://www.helm.sh/&#34; target=&#34;_blank&#34;&gt;Helm&lt;/a&gt; is THE package manager of Kubernetes and is used subsequently to deploy all other components of Jenkins X.&lt;/p&gt;

&lt;h3 id=&#34;setup-the-ingress-controller&#34;&gt;Setup the Ingress controller&lt;/h3&gt;

&lt;p&gt;In a Kubernetes cluster, services and pods have IPs that are only routable from by the cluster network. In order for traffic to flow into the cluster, an Ingress must be created. An ingress is a collection of rules for routing traffic to your services inside Kubernetes. The ingress rules are configured in an ingress resource held on the Kubernetes API server, and an ingress controller has to be created to fulfil those ingress rules. Jenkins X does all this for you by setting up an ingress controller and associated backend plus ingress rules for the following services (once deployed):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;chartmuseum&lt;/li&gt;
&lt;li&gt;docker-registry&lt;/li&gt;
&lt;li&gt;jenkins&lt;/li&gt;
&lt;li&gt;monocular&lt;/li&gt;
&lt;li&gt;nexus&lt;/li&gt;
&lt;/ul&gt;



&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;

By default, Jenkins X will expose the ingress via the &lt;em&gt;nip.io&lt;/em&gt; domain and generate self-signed certificates. You can easily adapt them by using our own custom domain and certificate after the installation with &lt;code&gt;jx upgrade ingress --cluster&lt;/code&gt;
&lt;/div&gt;


&lt;h3 id=&#34;configure-git-source-repository&#34;&gt;Configure git source repository&lt;/h3&gt;

&lt;p&gt;Jenkins X requires a git repository provider to be able to create the environment repositories. It defaults to GitHub if you did not provide a &lt;em&gt;git-provider-url&lt;/em&gt; parameter. You need to provide a username and a token that would be used to interact with the git, especially Jenkins.&lt;/p&gt;

&lt;h2 id=&#34;create-admin-secrets&#34;&gt;Create Admin secrets&lt;/h2&gt;

&lt;p&gt;Jenkins X generates an administration password for Monocular/Nexus/Jenkins and save it in secrets. It then retrieves git secrets for the helm install (so they can be used in the pipelines).&lt;/p&gt;

&lt;h3 id=&#34;clone-the-cloud-environments-repo&#34;&gt;Clone the cloud environments repo&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/jenkins-x/cloud-environments&#34; target=&#34;_blank&#34;&gt;cloud environment repository&lt;/a&gt; holds all the specific configuration and encrypted secrets that will be applied to the Jenkins Platform on your Kubernetes cluster. The secrets are encrypted and unencrypted by the Helm package manager.&lt;/p&gt;

&lt;h2 id=&#34;install-the-jenkins-x-platform&#34;&gt;Install the Jenkins X platform&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform&#34; target=&#34;_blank&#34;&gt;Jenkins X Platform&lt;/a&gt; holds the Helm charts for installing the components that provide the Jenkins X true CD solution. These include&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jenkinsci/jenkins&#34; target=&#34;_blank&#34;&gt;Jenkins&lt;/a&gt; a CI/CD pipeline solution&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sonatype.com/nexus-repository-oss&#34; target=&#34;_blank&#34;&gt;Nexus&lt;/a&gt; an artifact repository&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes-helm/chartmuseum&#34; target=&#34;_blank&#34;&gt;ChartMuseum&lt;/a&gt; - a Helm Chart repository&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes-helm/monocular&#34; target=&#34;_blank&#34;&gt;Monocular&lt;/a&gt; which provides a Web UI for searching and discovering charts deployed into your cluster via Jenkins X.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
